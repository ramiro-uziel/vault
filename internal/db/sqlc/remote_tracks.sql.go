// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: remote_tracks.sql

package db

import (
	"context"
	"database/sql"
)

const createRemoteTrack = `-- name: CreateRemoteTrack :one
INSERT INTO remote_tracks (local_user_id, local_project_id, remote_instance_url, remote_track_id, share_token, title, artist, album, cached_metadata)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, local_user_id, local_project_id, remote_instance_url, remote_track_id, share_token, title, artist, album, cached_metadata, created_at, updated_at
`

type CreateRemoteTrackParams struct {
	LocalUserID       int64          `json:"local_user_id"`
	LocalProjectID    int64          `json:"local_project_id"`
	RemoteInstanceUrl string         `json:"remote_instance_url"`
	RemoteTrackID     int64          `json:"remote_track_id"`
	ShareToken        string         `json:"share_token"`
	Title             string         `json:"title"`
	Artist            sql.NullString `json:"artist"`
	Album             sql.NullString `json:"album"`
	CachedMetadata    sql.NullString `json:"cached_metadata"`
}

func (q *Queries) CreateRemoteTrack(ctx context.Context, arg CreateRemoteTrackParams) (RemoteTrack, error) {
	row := q.db.QueryRowContext(ctx, createRemoteTrack,
		arg.LocalUserID,
		arg.LocalProjectID,
		arg.RemoteInstanceUrl,
		arg.RemoteTrackID,
		arg.ShareToken,
		arg.Title,
		arg.Artist,
		arg.Album,
		arg.CachedMetadata,
	)
	var i RemoteTrack
	err := row.Scan(
		&i.ID,
		&i.LocalUserID,
		&i.LocalProjectID,
		&i.RemoteInstanceUrl,
		&i.RemoteTrackID,
		&i.ShareToken,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.CachedMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRemoteTrack = `-- name: DeleteRemoteTrack :exec
DELETE FROM remote_tracks
WHERE id = ? AND local_user_id = ?
`

type DeleteRemoteTrackParams struct {
	ID          int64 `json:"id"`
	LocalUserID int64 `json:"local_user_id"`
}

func (q *Queries) DeleteRemoteTrack(ctx context.Context, arg DeleteRemoteTrackParams) error {
	_, err := q.db.ExecContext(ctx, deleteRemoteTrack, arg.ID, arg.LocalUserID)
	return err
}

const getRemoteTrack = `-- name: GetRemoteTrack :one
SELECT id, local_user_id, local_project_id, remote_instance_url, remote_track_id, share_token, title, artist, album, cached_metadata, created_at, updated_at FROM remote_tracks
WHERE id = ? AND local_user_id = ?
`

type GetRemoteTrackParams struct {
	ID          int64 `json:"id"`
	LocalUserID int64 `json:"local_user_id"`
}

func (q *Queries) GetRemoteTrack(ctx context.Context, arg GetRemoteTrackParams) (RemoteTrack, error) {
	row := q.db.QueryRowContext(ctx, getRemoteTrack, arg.ID, arg.LocalUserID)
	var i RemoteTrack
	err := row.Scan(
		&i.ID,
		&i.LocalUserID,
		&i.LocalProjectID,
		&i.RemoteInstanceUrl,
		&i.RemoteTrackID,
		&i.ShareToken,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.CachedMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRemoteTracksByProject = `-- name: ListRemoteTracksByProject :many
SELECT id, local_user_id, local_project_id, remote_instance_url, remote_track_id, share_token, title, artist, album, cached_metadata, created_at, updated_at FROM remote_tracks
WHERE local_user_id = ? AND local_project_id = ?
ORDER BY created_at DESC
`

type ListRemoteTracksByProjectParams struct {
	LocalUserID    int64 `json:"local_user_id"`
	LocalProjectID int64 `json:"local_project_id"`
}

func (q *Queries) ListRemoteTracksByProject(ctx context.Context, arg ListRemoteTracksByProjectParams) ([]RemoteTrack, error) {
	rows, err := q.db.QueryContext(ctx, listRemoteTracksByProject, arg.LocalUserID, arg.LocalProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RemoteTrack{}
	for rows.Next() {
		var i RemoteTrack
		if err := rows.Scan(
			&i.ID,
			&i.LocalUserID,
			&i.LocalProjectID,
			&i.RemoteInstanceUrl,
			&i.RemoteTrackID,
			&i.ShareToken,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.CachedMetadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRemoteTracksByUser = `-- name: ListRemoteTracksByUser :many
SELECT id, local_user_id, local_project_id, remote_instance_url, remote_track_id, share_token, title, artist, album, cached_metadata, created_at, updated_at FROM remote_tracks
WHERE local_user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListRemoteTracksByUser(ctx context.Context, localUserID int64) ([]RemoteTrack, error) {
	rows, err := q.db.QueryContext(ctx, listRemoteTracksByUser, localUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RemoteTrack{}
	for rows.Next() {
		var i RemoteTrack
		if err := rows.Scan(
			&i.ID,
			&i.LocalUserID,
			&i.LocalProjectID,
			&i.RemoteInstanceUrl,
			&i.RemoteTrackID,
			&i.ShareToken,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.CachedMetadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRemoteTrack = `-- name: UpdateRemoteTrack :one
UPDATE remote_tracks
SET title = COALESCE(?, title),
    artist = COALESCE(?, artist),
    album = COALESCE(?, album),
    cached_metadata = COALESCE(?, cached_metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND local_user_id = ?
RETURNING id, local_user_id, local_project_id, remote_instance_url, remote_track_id, share_token, title, artist, album, cached_metadata, created_at, updated_at
`

type UpdateRemoteTrackParams struct {
	Title          string         `json:"title"`
	Artist         sql.NullString `json:"artist"`
	Album          sql.NullString `json:"album"`
	CachedMetadata sql.NullString `json:"cached_metadata"`
	ID             int64          `json:"id"`
	LocalUserID    int64          `json:"local_user_id"`
}

func (q *Queries) UpdateRemoteTrack(ctx context.Context, arg UpdateRemoteTrackParams) (RemoteTrack, error) {
	row := q.db.QueryRowContext(ctx, updateRemoteTrack,
		arg.Title,
		arg.Artist,
		arg.Album,
		arg.CachedMetadata,
		arg.ID,
		arg.LocalUserID,
	)
	var i RemoteTrack
	err := row.Scan(
		&i.ID,
		&i.LocalUserID,
		&i.LocalProjectID,
		&i.RemoteInstanceUrl,
		&i.RemoteTrackID,
		&i.ShareToken,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.CachedMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
