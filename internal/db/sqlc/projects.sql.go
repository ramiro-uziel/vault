// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package db

import (
	"context"
	"database/sql"
)

const clearProjectCover = `-- name: ClearProjectCover :one
UPDATE projects
SET cover_art_path = NULL,
    cover_art_mime = NULL,
    cover_art_updated_at = NULL,
    cover_processed = FALSE,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

func (q *Queries) ClearProjectCover(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRowContext(ctx, clearProjectCover, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (user_id, name, description, quality_override, public_id, author_override, folder_id)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

type CreateProjectParams struct {
	UserID          int64          `json:"user_id"`
	Name            string         `json:"name"`
	Description     sql.NullString `json:"description"`
	QualityOverride sql.NullString `json:"quality_override"`
	PublicID        string         `json:"public_id"`
	AuthorOverride  sql.NullString `json:"author_override"`
	FolderID        sql.NullInt64  `json:"folder_id"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.QualityOverride,
		arg.PublicID,
		arg.AuthorOverride,
		arg.FolderID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = ? AND user_id = ?
`

type DeleteProjectParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.ExecContext(ctx, deleteProject, arg.ID, arg.UserID)
	return err
}

const getProject = `-- name: GetProject :one
SELECT id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed FROM projects
WHERE id = ? AND user_id = ?
`

type GetProjectParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetProject(ctx context.Context, arg GetProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProject, arg.ID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed FROM projects
WHERE id = ?
`

func (q *Queries) GetProjectByID(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const getProjectByPublicID = `-- name: GetProjectByPublicID :one
SELECT
    p.id, p.user_id, p.name, p.description, p.quality_override, p.created_at, p.updated_at, p.public_id, p.cover_art_path, p.cover_art_mime, p.cover_art_updated_at, p.author_override, p.folder_id, p.folder_added_at, p.notes, p.notes_author_name, p.notes_updated_at, p.visibility_status, p.allow_editing, p.allow_downloads, p.password_hash, p.origin_instance_url, p.shared_with_instance_users, p.custom_order, p.cover_processed,
    CASE WHEN EXISTS (
        SELECT 1 FROM user_project_shares ups
        WHERE ups.project_id = p.id
    ) THEN 1 ELSE 0 END as is_shared
FROM projects p
WHERE p.public_id = ? AND p.user_id = ?
`

type GetProjectByPublicIDParams struct {
	PublicID string `json:"public_id"`
	UserID   int64  `json:"user_id"`
}

type GetProjectByPublicIDRow struct {
	ID                      int64          `json:"id"`
	UserID                  int64          `json:"user_id"`
	Name                    string         `json:"name"`
	Description             sql.NullString `json:"description"`
	QualityOverride         sql.NullString `json:"quality_override"`
	CreatedAt               sql.NullTime   `json:"created_at"`
	UpdatedAt               sql.NullTime   `json:"updated_at"`
	PublicID                string         `json:"public_id"`
	CoverArtPath            sql.NullString `json:"cover_art_path"`
	CoverArtMime            sql.NullString `json:"cover_art_mime"`
	CoverArtUpdatedAt       sql.NullTime   `json:"cover_art_updated_at"`
	AuthorOverride          sql.NullString `json:"author_override"`
	FolderID                sql.NullInt64  `json:"folder_id"`
	FolderAddedAt           sql.NullTime   `json:"folder_added_at"`
	Notes                   sql.NullString `json:"notes"`
	NotesAuthorName         sql.NullString `json:"notes_author_name"`
	NotesUpdatedAt          sql.NullTime   `json:"notes_updated_at"`
	VisibilityStatus        string         `json:"visibility_status"`
	AllowEditing            bool           `json:"allow_editing"`
	AllowDownloads          bool           `json:"allow_downloads"`
	PasswordHash            sql.NullString `json:"password_hash"`
	OriginInstanceUrl       sql.NullString `json:"origin_instance_url"`
	SharedWithInstanceUsers sql.NullBool   `json:"shared_with_instance_users"`
	CustomOrder             int64          `json:"custom_order"`
	CoverProcessed          sql.NullBool   `json:"cover_processed"`
	IsShared                int64          `json:"is_shared"`
}

func (q *Queries) GetProjectByPublicID(ctx context.Context, arg GetProjectByPublicIDParams) (GetProjectByPublicIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectByPublicID, arg.PublicID, arg.UserID)
	var i GetProjectByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
		&i.IsShared,
	)
	return i, err
}

const getProjectByPublicIDNoFilter = `-- name: GetProjectByPublicIDNoFilter :one
SELECT
    p.id, p.user_id, p.name, p.description, p.quality_override, p.created_at, p.updated_at, p.public_id, p.cover_art_path, p.cover_art_mime, p.cover_art_updated_at, p.author_override, p.folder_id, p.folder_added_at, p.notes, p.notes_author_name, p.notes_updated_at, p.visibility_status, p.allow_editing, p.allow_downloads, p.password_hash, p.origin_instance_url, p.shared_with_instance_users, p.custom_order, p.cover_processed,
    CASE WHEN EXISTS (
        SELECT 1 FROM user_project_shares ups
        WHERE ups.project_id = p.id
    ) THEN 1 ELSE 0 END as is_shared
FROM projects p
WHERE p.public_id = ?
`

type GetProjectByPublicIDNoFilterRow struct {
	ID                      int64          `json:"id"`
	UserID                  int64          `json:"user_id"`
	Name                    string         `json:"name"`
	Description             sql.NullString `json:"description"`
	QualityOverride         sql.NullString `json:"quality_override"`
	CreatedAt               sql.NullTime   `json:"created_at"`
	UpdatedAt               sql.NullTime   `json:"updated_at"`
	PublicID                string         `json:"public_id"`
	CoverArtPath            sql.NullString `json:"cover_art_path"`
	CoverArtMime            sql.NullString `json:"cover_art_mime"`
	CoverArtUpdatedAt       sql.NullTime   `json:"cover_art_updated_at"`
	AuthorOverride          sql.NullString `json:"author_override"`
	FolderID                sql.NullInt64  `json:"folder_id"`
	FolderAddedAt           sql.NullTime   `json:"folder_added_at"`
	Notes                   sql.NullString `json:"notes"`
	NotesAuthorName         sql.NullString `json:"notes_author_name"`
	NotesUpdatedAt          sql.NullTime   `json:"notes_updated_at"`
	VisibilityStatus        string         `json:"visibility_status"`
	AllowEditing            bool           `json:"allow_editing"`
	AllowDownloads          bool           `json:"allow_downloads"`
	PasswordHash            sql.NullString `json:"password_hash"`
	OriginInstanceUrl       sql.NullString `json:"origin_instance_url"`
	SharedWithInstanceUsers sql.NullBool   `json:"shared_with_instance_users"`
	CustomOrder             int64          `json:"custom_order"`
	CoverProcessed          sql.NullBool   `json:"cover_processed"`
	IsShared                int64          `json:"is_shared"`
}

func (q *Queries) GetProjectByPublicIDNoFilter(ctx context.Context, publicID string) (GetProjectByPublicIDNoFilterRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectByPublicIDNoFilter, publicID)
	var i GetProjectByPublicIDNoFilterRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
		&i.IsShared,
	)
	return i, err
}

const listProjectsByUser = `-- name: ListProjectsByUser :many
SELECT
    p.id, p.user_id, p.name, p.description, p.quality_override, p.created_at, p.updated_at, p.public_id, p.cover_art_path, p.cover_art_mime, p.cover_art_updated_at, p.author_override, p.folder_id, p.folder_added_at, p.notes, p.notes_author_name, p.notes_updated_at, p.visibility_status, p.allow_editing, p.allow_downloads, p.password_hash, p.origin_instance_url, p.shared_with_instance_users, p.custom_order, p.cover_processed,
    u.username as owner_username
FROM projects p
JOIN users u ON p.user_id = u.id
WHERE p.user_id = ?
ORDER BY p.created_at DESC
`

type ListProjectsByUserRow struct {
	ID                      int64          `json:"id"`
	UserID                  int64          `json:"user_id"`
	Name                    string         `json:"name"`
	Description             sql.NullString `json:"description"`
	QualityOverride         sql.NullString `json:"quality_override"`
	CreatedAt               sql.NullTime   `json:"created_at"`
	UpdatedAt               sql.NullTime   `json:"updated_at"`
	PublicID                string         `json:"public_id"`
	CoverArtPath            sql.NullString `json:"cover_art_path"`
	CoverArtMime            sql.NullString `json:"cover_art_mime"`
	CoverArtUpdatedAt       sql.NullTime   `json:"cover_art_updated_at"`
	AuthorOverride          sql.NullString `json:"author_override"`
	FolderID                sql.NullInt64  `json:"folder_id"`
	FolderAddedAt           sql.NullTime   `json:"folder_added_at"`
	Notes                   sql.NullString `json:"notes"`
	NotesAuthorName         sql.NullString `json:"notes_author_name"`
	NotesUpdatedAt          sql.NullTime   `json:"notes_updated_at"`
	VisibilityStatus        string         `json:"visibility_status"`
	AllowEditing            bool           `json:"allow_editing"`
	AllowDownloads          bool           `json:"allow_downloads"`
	PasswordHash            sql.NullString `json:"password_hash"`
	OriginInstanceUrl       sql.NullString `json:"origin_instance_url"`
	SharedWithInstanceUsers sql.NullBool   `json:"shared_with_instance_users"`
	CustomOrder             int64          `json:"custom_order"`
	CoverProcessed          sql.NullBool   `json:"cover_processed"`
	OwnerUsername           string         `json:"owner_username"`
}

func (q *Queries) ListProjectsByUser(ctx context.Context, userID int64) ([]ListProjectsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectsByUserRow{}
	for rows.Next() {
		var i ListProjectsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.QualityOverride,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublicID,
			&i.CoverArtPath,
			&i.CoverArtMime,
			&i.CoverArtUpdatedAt,
			&i.AuthorOverride,
			&i.FolderID,
			&i.FolderAddedAt,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
			&i.CustomOrder,
			&i.CoverProcessed,
			&i.OwnerUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootProjects = `-- name: ListRootProjects :many
SELECT
    p.id, p.user_id, p.name, p.description, p.quality_override, p.created_at, p.updated_at, p.public_id, p.cover_art_path, p.cover_art_mime, p.cover_art_updated_at, p.author_override, p.folder_id, p.folder_added_at, p.notes, p.notes_author_name, p.notes_updated_at, p.visibility_status, p.allow_editing, p.allow_downloads, p.password_hash, p.origin_instance_url, p.shared_with_instance_users, p.custom_order, p.cover_processed,
    u.username as owner_username
FROM projects p
JOIN users u ON p.user_id = u.id
WHERE p.user_id = ? AND p.folder_id IS NULL
ORDER BY p.created_at ASC
`

type ListRootProjectsRow struct {
	ID                      int64          `json:"id"`
	UserID                  int64          `json:"user_id"`
	Name                    string         `json:"name"`
	Description             sql.NullString `json:"description"`
	QualityOverride         sql.NullString `json:"quality_override"`
	CreatedAt               sql.NullTime   `json:"created_at"`
	UpdatedAt               sql.NullTime   `json:"updated_at"`
	PublicID                string         `json:"public_id"`
	CoverArtPath            sql.NullString `json:"cover_art_path"`
	CoverArtMime            sql.NullString `json:"cover_art_mime"`
	CoverArtUpdatedAt       sql.NullTime   `json:"cover_art_updated_at"`
	AuthorOverride          sql.NullString `json:"author_override"`
	FolderID                sql.NullInt64  `json:"folder_id"`
	FolderAddedAt           sql.NullTime   `json:"folder_added_at"`
	Notes                   sql.NullString `json:"notes"`
	NotesAuthorName         sql.NullString `json:"notes_author_name"`
	NotesUpdatedAt          sql.NullTime   `json:"notes_updated_at"`
	VisibilityStatus        string         `json:"visibility_status"`
	AllowEditing            bool           `json:"allow_editing"`
	AllowDownloads          bool           `json:"allow_downloads"`
	PasswordHash            sql.NullString `json:"password_hash"`
	OriginInstanceUrl       sql.NullString `json:"origin_instance_url"`
	SharedWithInstanceUsers sql.NullBool   `json:"shared_with_instance_users"`
	CustomOrder             int64          `json:"custom_order"`
	CoverProcessed          sql.NullBool   `json:"cover_processed"`
	OwnerUsername           string         `json:"owner_username"`
}

func (q *Queries) ListRootProjects(ctx context.Context, userID int64) ([]ListRootProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRootProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRootProjectsRow{}
	for rows.Next() {
		var i ListRootProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.QualityOverride,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublicID,
			&i.CoverArtPath,
			&i.CoverArtMime,
			&i.CoverArtUpdatedAt,
			&i.AuthorOverride,
			&i.FolderID,
			&i.FolderAddedAt,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
			&i.CustomOrder,
			&i.CoverProcessed,
			&i.OwnerUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootProjectsWithCustomOrder = `-- name: ListRootProjectsWithCustomOrder :many
SELECT id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed FROM projects
WHERE user_id = ? AND folder_id IS NULL
ORDER BY custom_order ASC, created_at DESC
`

func (q *Queries) ListRootProjectsWithCustomOrder(ctx context.Context, userID int64) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listRootProjectsWithCustomOrder, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.QualityOverride,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublicID,
			&i.CoverArtPath,
			&i.CoverArtMime,
			&i.CoverArtUpdatedAt,
			&i.AuthorOverride,
			&i.FolderID,
			&i.FolderAddedAt,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
			&i.CustomOrder,
			&i.CoverProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedCovers = `-- name: ListUnprocessedCovers :many
SELECT id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed FROM projects
WHERE cover_art_path IS NOT NULL AND cover_processed = FALSE
`

func (q *Queries) ListUnprocessedCovers(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listUnprocessedCovers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.QualityOverride,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublicID,
			&i.CoverArtPath,
			&i.CoverArtMime,
			&i.CoverArtUpdatedAt,
			&i.AuthorOverride,
			&i.FolderID,
			&i.FolderAddedAt,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
			&i.CustomOrder,
			&i.CoverProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCoverProcessed = `-- name: MarkCoverProcessed :exec
UPDATE projects
SET cover_processed = TRUE
WHERE id = ?
`

func (q *Queries) MarkCoverProcessed(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markCoverProcessed, id)
	return err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET name = COALESCE(?, name),
    description = COALESCE(?, description),
    quality_override = ?,
    author_override = ?,
    notes = COALESCE(?, notes),
    notes_author_name = COALESCE(?, notes_author_name),
    notes_updated_at = CASE WHEN ? IS NOT NULL THEN CURRENT_TIMESTAMP ELSE notes_updated_at END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

type UpdateProjectParams struct {
	Name            string         `json:"name"`
	Description     sql.NullString `json:"description"`
	QualityOverride sql.NullString `json:"quality_override"`
	AuthorOverride  sql.NullString `json:"author_override"`
	Notes           sql.NullString `json:"notes"`
	NotesAuthorName sql.NullString `json:"notes_author_name"`
	Column7         interface{}    `json:"column_7"`
	ID              int64          `json:"id"`
	UserID          int64          `json:"user_id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.Name,
		arg.Description,
		arg.QualityOverride,
		arg.AuthorOverride,
		arg.Notes,
		arg.NotesAuthorName,
		arg.Column7,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const updateProjectCover = `-- name: UpdateProjectCover :one
UPDATE projects
SET cover_art_path = ?,
    cover_art_mime = ?,
    cover_art_updated_at = CURRENT_TIMESTAMP,
    cover_processed = TRUE,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

type UpdateProjectCoverParams struct {
	CoverArtPath sql.NullString `json:"cover_art_path"`
	CoverArtMime sql.NullString `json:"cover_art_mime"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateProjectCover(ctx context.Context, arg UpdateProjectCoverParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectCover, arg.CoverArtPath, arg.CoverArtMime, arg.ID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const updateProjectCustomOrder = `-- name: UpdateProjectCustomOrder :one
UPDATE projects
SET custom_order = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

type UpdateProjectCustomOrderParams struct {
	CustomOrder int64 `json:"custom_order"`
	ID          int64 `json:"id"`
	UserID      int64 `json:"user_id"`
}

func (q *Queries) UpdateProjectCustomOrder(ctx context.Context, arg UpdateProjectCustomOrderParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectCustomOrder, arg.CustomOrder, arg.ID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const updateProjectFolder = `-- name: UpdateProjectFolder :one
UPDATE projects
SET folder_id = ?,
    folder_added_at = CASE WHEN ? IS NOT NULL THEN CURRENT_TIMESTAMP ELSE NULL END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

type UpdateProjectFolderParams struct {
	FolderID sql.NullInt64 `json:"folder_id"`
	Column2  interface{}   `json:"column_2"`
	ID       int64         `json:"id"`
	UserID   int64         `json:"user_id"`
}

func (q *Queries) UpdateProjectFolder(ctx context.Context, arg UpdateProjectFolderParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectFolder,
		arg.FolderID,
		arg.Column2,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const updateProjectFolderWithTimestamp = `-- name: UpdateProjectFolderWithTimestamp :one
UPDATE projects
SET folder_id = ?,
    folder_added_at = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

type UpdateProjectFolderWithTimestampParams struct {
	FolderID      sql.NullInt64 `json:"folder_id"`
	FolderAddedAt sql.NullTime  `json:"folder_added_at"`
	ID            int64         `json:"id"`
	UserID        int64         `json:"user_id"`
}

func (q *Queries) UpdateProjectFolderWithTimestamp(ctx context.Context, arg UpdateProjectFolderWithTimestampParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectFolderWithTimestamp,
		arg.FolderID,
		arg.FolderAddedAt,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const updateProjectNotes = `-- name: UpdateProjectNotes :one
UPDATE projects
SET notes = ?,
    notes_author_name = ?,
    notes_updated_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

type UpdateProjectNotesParams struct {
	Notes           sql.NullString `json:"notes"`
	NotesAuthorName sql.NullString `json:"notes_author_name"`
	ID              int64          `json:"id"`
	UserID          int64          `json:"user_id"`
}

func (q *Queries) UpdateProjectNotes(ctx context.Context, arg UpdateProjectNotesParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectNotes,
		arg.Notes,
		arg.NotesAuthorName,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}
