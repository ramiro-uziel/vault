// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organization.sql

package db

import (
	"context"
	"database/sql"
)

const createSharedProjectOrganization = `-- name: CreateSharedProjectOrganization :one
INSERT INTO user_shared_project_organization (
    user_id,
    project_id,
    folder_id,
    custom_order
) VALUES (?, ?, ?, ?)
RETURNING id, user_id, project_id, folder_id, custom_order, created_at, updated_at
`

type CreateSharedProjectOrganizationParams struct {
	UserID      int64         `json:"user_id"`
	ProjectID   int64         `json:"project_id"`
	FolderID    sql.NullInt64 `json:"folder_id"`
	CustomOrder int64         `json:"custom_order"`
}

func (q *Queries) CreateSharedProjectOrganization(ctx context.Context, arg CreateSharedProjectOrganizationParams) (UserSharedProjectOrganization, error) {
	row := q.db.QueryRowContext(ctx, createSharedProjectOrganization,
		arg.UserID,
		arg.ProjectID,
		arg.FolderID,
		arg.CustomOrder,
	)
	var i UserSharedProjectOrganization
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.FolderID,
		&i.CustomOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSharedTrackOrganization = `-- name: CreateSharedTrackOrganization :one
INSERT INTO user_shared_track_organization (
    user_id,
    track_id,
    folder_id,
    custom_order
) VALUES (?, ?, ?, ?)
RETURNING id, user_id, track_id, folder_id, custom_order, created_at, updated_at
`

type CreateSharedTrackOrganizationParams struct {
	UserID      int64         `json:"user_id"`
	TrackID     int64         `json:"track_id"`
	FolderID    sql.NullInt64 `json:"folder_id"`
	CustomOrder int64         `json:"custom_order"`
}

func (q *Queries) CreateSharedTrackOrganization(ctx context.Context, arg CreateSharedTrackOrganizationParams) (UserSharedTrackOrganization, error) {
	row := q.db.QueryRowContext(ctx, createSharedTrackOrganization,
		arg.UserID,
		arg.TrackID,
		arg.FolderID,
		arg.CustomOrder,
	)
	var i UserSharedTrackOrganization
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TrackID,
		&i.FolderID,
		&i.CustomOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllSharedProjectOrganizationsInFolder = `-- name: DeleteAllSharedProjectOrganizationsInFolder :exec
DELETE FROM user_shared_project_organization
WHERE user_id = ? AND folder_id = ?
`

type DeleteAllSharedProjectOrganizationsInFolderParams struct {
	UserID   int64         `json:"user_id"`
	FolderID sql.NullInt64 `json:"folder_id"`
}

func (q *Queries) DeleteAllSharedProjectOrganizationsInFolder(ctx context.Context, arg DeleteAllSharedProjectOrganizationsInFolderParams) error {
	_, err := q.db.ExecContext(ctx, deleteAllSharedProjectOrganizationsInFolder, arg.UserID, arg.FolderID)
	return err
}

const deleteAllSharedTrackOrganizationsInFolder = `-- name: DeleteAllSharedTrackOrganizationsInFolder :exec
DELETE FROM user_shared_track_organization
WHERE user_id = ? AND folder_id = ?
`

type DeleteAllSharedTrackOrganizationsInFolderParams struct {
	UserID   int64         `json:"user_id"`
	FolderID sql.NullInt64 `json:"folder_id"`
}

func (q *Queries) DeleteAllSharedTrackOrganizationsInFolder(ctx context.Context, arg DeleteAllSharedTrackOrganizationsInFolderParams) error {
	_, err := q.db.ExecContext(ctx, deleteAllSharedTrackOrganizationsInFolder, arg.UserID, arg.FolderID)
	return err
}

const deleteSharedProjectOrganization = `-- name: DeleteSharedProjectOrganization :exec
DELETE FROM user_shared_project_organization
WHERE user_id = ? AND project_id = ?
`

type DeleteSharedProjectOrganizationParams struct {
	UserID    int64 `json:"user_id"`
	ProjectID int64 `json:"project_id"`
}

func (q *Queries) DeleteSharedProjectOrganization(ctx context.Context, arg DeleteSharedProjectOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, deleteSharedProjectOrganization, arg.UserID, arg.ProjectID)
	return err
}

const deleteSharedTrackOrganization = `-- name: DeleteSharedTrackOrganization :exec
DELETE FROM user_shared_track_organization
WHERE user_id = ? AND track_id = ?
`

type DeleteSharedTrackOrganizationParams struct {
	UserID  int64 `json:"user_id"`
	TrackID int64 `json:"track_id"`
}

func (q *Queries) DeleteSharedTrackOrganization(ctx context.Context, arg DeleteSharedTrackOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, deleteSharedTrackOrganization, arg.UserID, arg.TrackID)
	return err
}

const getMaxOrderAtRoot = `-- name: GetMaxOrderAtRoot :one
SELECT COALESCE(MAX(max_order), -1) as max_order FROM (
    -- Max order from owned projects
    SELECT COALESCE(MAX(p.custom_order), -1) as max_order
    FROM projects p
    WHERE p.user_id = ?1 AND p.folder_id IS NULL
    UNION ALL
    -- Max order from shared projects
    SELECT COALESCE(MAX(spo.custom_order), -1) as max_order
    FROM user_shared_project_organization spo
    WHERE spo.user_id = ?1 AND spo.folder_id IS NULL
    UNION ALL
    -- Max order from shared tracks
    SELECT COALESCE(MAX(sto.custom_order), -1) as max_order
    FROM user_shared_track_organization sto
    WHERE sto.user_id = ?1 AND sto.folder_id IS NULL
    UNION ALL
    -- Max order from root folders
    SELECT COALESCE(MAX(f.folder_order), -1) as max_order
    FROM folders f
    WHERE f.user_id = ?1 AND f.parent_id IS NULL
)
`

// Get the maximum custom_order across all item types at root level
func (q *Queries) GetMaxOrderAtRoot(ctx context.Context, userID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxOrderAtRoot, userID)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const getMaxOrderInFolder = `-- name: GetMaxOrderInFolder :one
SELECT COALESCE(MAX(max_order), -1) as max_order FROM (
    -- Max order from owned projects
    SELECT COALESCE(MAX(p.custom_order), -1) as max_order
    FROM projects p
    WHERE p.user_id = ?1 AND p.folder_id = ?2
    UNION ALL
    -- Max order from shared projects
    SELECT COALESCE(MAX(spo.custom_order), -1) as max_order
    FROM user_shared_project_organization spo
    WHERE spo.user_id = ?1 AND spo.folder_id = ?2
    UNION ALL
    -- Max order from shared tracks
    SELECT COALESCE(MAX(sto.custom_order), -1) as max_order
    FROM user_shared_track_organization sto
    WHERE sto.user_id = ?1 AND sto.folder_id = ?2
    UNION ALL
    -- Max order from subfolders
    SELECT COALESCE(MAX(f.folder_order), -1) as max_order
    FROM folders f
    WHERE f.user_id = ?1 AND f.parent_id = ?2
)
`

type GetMaxOrderInFolderParams struct {
	UserID   int64         `json:"user_id"`
	FolderID sql.NullInt64 `json:"folder_id"`
}

// Get the maximum custom_order across all item types in a folder
// This ensures new items are appended after existing projects, tracks, and subfolders
func (q *Queries) GetMaxOrderInFolder(ctx context.Context, arg GetMaxOrderInFolderParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxOrderInFolder, arg.UserID, arg.FolderID)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const getMaxProjectOrderAtRoot = `-- name: GetMaxProjectOrderAtRoot :one
SELECT COALESCE(MAX(custom_order), -1) as max_order
FROM (
    SELECT p.custom_order as custom_order FROM projects p WHERE p.user_id = ? AND p.folder_id IS NULL
    UNION ALL
    SELECT o.custom_order as custom_order FROM user_shared_project_organization o WHERE o.user_id = ? AND o.folder_id IS NULL
) combined
`

type GetMaxProjectOrderAtRootParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

func (q *Queries) GetMaxProjectOrderAtRoot(ctx context.Context, arg GetMaxProjectOrderAtRootParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxProjectOrderAtRoot, arg.UserID, arg.UserID_2)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const getMaxProjectOrderInFolder = `-- name: GetMaxProjectOrderInFolder :one
SELECT COALESCE(MAX(custom_order), -1) as max_order
FROM (
    SELECT p.custom_order as custom_order FROM projects p WHERE p.user_id = ? AND p.folder_id = ?
    UNION ALL
    SELECT o.custom_order as custom_order FROM user_shared_project_organization o WHERE o.user_id = ? AND o.folder_id = ?
) combined
`

type GetMaxProjectOrderInFolderParams struct {
	UserID     int64         `json:"user_id"`
	FolderID   sql.NullInt64 `json:"folder_id"`
	UserID_2   int64         `json:"user_id_2"`
	FolderID_2 sql.NullInt64 `json:"folder_id_2"`
}

func (q *Queries) GetMaxProjectOrderInFolder(ctx context.Context, arg GetMaxProjectOrderInFolderParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxProjectOrderInFolder,
		arg.UserID,
		arg.FolderID,
		arg.UserID_2,
		arg.FolderID_2,
	)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const getMaxTrackOrderAtRoot = `-- name: GetMaxTrackOrderAtRoot :one
SELECT COALESCE(MAX(custom_order), -1) as max_order
FROM user_shared_track_organization
WHERE user_id = ? AND folder_id IS NULL
`

func (q *Queries) GetMaxTrackOrderAtRoot(ctx context.Context, userID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxTrackOrderAtRoot, userID)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const getMaxTrackOrderInFolder = `-- name: GetMaxTrackOrderInFolder :one
SELECT COALESCE(MAX(custom_order), -1) as max_order
FROM user_shared_track_organization
WHERE user_id = ? AND folder_id = ?
`

type GetMaxTrackOrderInFolderParams struct {
	UserID   int64         `json:"user_id"`
	FolderID sql.NullInt64 `json:"folder_id"`
}

func (q *Queries) GetMaxTrackOrderInFolder(ctx context.Context, arg GetMaxTrackOrderInFolderParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxTrackOrderInFolder, arg.UserID, arg.FolderID)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const getUserSharedProjectOrganization = `-- name: GetUserSharedProjectOrganization :one
SELECT id, user_id, project_id, folder_id, custom_order, created_at, updated_at FROM user_shared_project_organization
WHERE user_id = ? AND project_id = ?
`

type GetUserSharedProjectOrganizationParams struct {
	UserID    int64 `json:"user_id"`
	ProjectID int64 `json:"project_id"`
}

func (q *Queries) GetUserSharedProjectOrganization(ctx context.Context, arg GetUserSharedProjectOrganizationParams) (UserSharedProjectOrganization, error) {
	row := q.db.QueryRowContext(ctx, getUserSharedProjectOrganization, arg.UserID, arg.ProjectID)
	var i UserSharedProjectOrganization
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.FolderID,
		&i.CustomOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserSharedTrackOrganization = `-- name: GetUserSharedTrackOrganization :one
SELECT id, user_id, track_id, folder_id, custom_order, created_at, updated_at FROM user_shared_track_organization
WHERE user_id = ? AND track_id = ?
`

type GetUserSharedTrackOrganizationParams struct {
	UserID  int64 `json:"user_id"`
	TrackID int64 `json:"track_id"`
}

func (q *Queries) GetUserSharedTrackOrganization(ctx context.Context, arg GetUserSharedTrackOrganizationParams) (UserSharedTrackOrganization, error) {
	row := q.db.QueryRowContext(ctx, getUserSharedTrackOrganization, arg.UserID, arg.TrackID)
	var i UserSharedTrackOrganization
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TrackID,
		&i.FolderID,
		&i.CustomOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSharedProjectOrganizationsAtRoot = `-- name: ListSharedProjectOrganizationsAtRoot :many
SELECT id, user_id, project_id, folder_id, custom_order, created_at, updated_at FROM user_shared_project_organization
WHERE user_id = ? AND folder_id IS NULL
ORDER BY custom_order ASC, created_at DESC
`

func (q *Queries) ListSharedProjectOrganizationsAtRoot(ctx context.Context, userID int64) ([]UserSharedProjectOrganization, error) {
	rows, err := q.db.QueryContext(ctx, listSharedProjectOrganizationsAtRoot, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSharedProjectOrganization{}
	for rows.Next() {
		var i UserSharedProjectOrganization
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.FolderID,
			&i.CustomOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSharedProjectOrganizationsInFolder = `-- name: ListSharedProjectOrganizationsInFolder :many
SELECT id, user_id, project_id, folder_id, custom_order, created_at, updated_at FROM user_shared_project_organization
WHERE user_id = ? AND folder_id = ?
ORDER BY custom_order ASC, created_at DESC
`

type ListSharedProjectOrganizationsInFolderParams struct {
	UserID   int64         `json:"user_id"`
	FolderID sql.NullInt64 `json:"folder_id"`
}

func (q *Queries) ListSharedProjectOrganizationsInFolder(ctx context.Context, arg ListSharedProjectOrganizationsInFolderParams) ([]UserSharedProjectOrganization, error) {
	rows, err := q.db.QueryContext(ctx, listSharedProjectOrganizationsInFolder, arg.UserID, arg.FolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSharedProjectOrganization{}
	for rows.Next() {
		var i UserSharedProjectOrganization
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.FolderID,
			&i.CustomOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSharedTrackOrganizationsAtRoot = `-- name: ListSharedTrackOrganizationsAtRoot :many
SELECT id, user_id, track_id, folder_id, custom_order, created_at, updated_at FROM user_shared_track_organization
WHERE user_id = ? AND folder_id IS NULL
ORDER BY custom_order ASC, created_at DESC
`

func (q *Queries) ListSharedTrackOrganizationsAtRoot(ctx context.Context, userID int64) ([]UserSharedTrackOrganization, error) {
	rows, err := q.db.QueryContext(ctx, listSharedTrackOrganizationsAtRoot, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSharedTrackOrganization{}
	for rows.Next() {
		var i UserSharedTrackOrganization
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TrackID,
			&i.FolderID,
			&i.CustomOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSharedTrackOrganizationsInFolder = `-- name: ListSharedTrackOrganizationsInFolder :many
SELECT id, user_id, track_id, folder_id, custom_order, created_at, updated_at FROM user_shared_track_organization
WHERE user_id = ? AND folder_id = ?
ORDER BY custom_order ASC, created_at DESC
`

type ListSharedTrackOrganizationsInFolderParams struct {
	UserID   int64         `json:"user_id"`
	FolderID sql.NullInt64 `json:"folder_id"`
}

func (q *Queries) ListSharedTrackOrganizationsInFolder(ctx context.Context, arg ListSharedTrackOrganizationsInFolderParams) ([]UserSharedTrackOrganization, error) {
	rows, err := q.db.QueryContext(ctx, listSharedTrackOrganizationsInFolder, arg.UserID, arg.FolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSharedTrackOrganization{}
	for rows.Next() {
		var i UserSharedTrackOrganization
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TrackID,
			&i.FolderID,
			&i.CustomOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSharedProjectOrganizations = `-- name: ListUserSharedProjectOrganizations :many
SELECT id, user_id, project_id, folder_id, custom_order, created_at, updated_at FROM user_shared_project_organization
WHERE user_id = ?
ORDER BY custom_order ASC, created_at DESC
`

func (q *Queries) ListUserSharedProjectOrganizations(ctx context.Context, userID int64) ([]UserSharedProjectOrganization, error) {
	rows, err := q.db.QueryContext(ctx, listUserSharedProjectOrganizations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSharedProjectOrganization{}
	for rows.Next() {
		var i UserSharedProjectOrganization
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.FolderID,
			&i.CustomOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSharedTrackOrganizations = `-- name: ListUserSharedTrackOrganizations :many
SELECT id, user_id, track_id, folder_id, custom_order, created_at, updated_at FROM user_shared_track_organization
WHERE user_id = ?
ORDER BY custom_order ASC, created_at DESC
`

func (q *Queries) ListUserSharedTrackOrganizations(ctx context.Context, userID int64) ([]UserSharedTrackOrganization, error) {
	rows, err := q.db.QueryContext(ctx, listUserSharedTrackOrganizations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSharedTrackOrganization{}
	for rows.Next() {
		var i UserSharedTrackOrganization
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TrackID,
			&i.FolderID,
			&i.CustomOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSharedProjectOrganization = `-- name: UpdateSharedProjectOrganization :one
UPDATE user_shared_project_organization
SET folder_id = ?,
    custom_order = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = ? AND project_id = ?
RETURNING id, user_id, project_id, folder_id, custom_order, created_at, updated_at
`

type UpdateSharedProjectOrganizationParams struct {
	FolderID    sql.NullInt64 `json:"folder_id"`
	CustomOrder int64         `json:"custom_order"`
	UserID      int64         `json:"user_id"`
	ProjectID   int64         `json:"project_id"`
}

func (q *Queries) UpdateSharedProjectOrganization(ctx context.Context, arg UpdateSharedProjectOrganizationParams) (UserSharedProjectOrganization, error) {
	row := q.db.QueryRowContext(ctx, updateSharedProjectOrganization,
		arg.FolderID,
		arg.CustomOrder,
		arg.UserID,
		arg.ProjectID,
	)
	var i UserSharedProjectOrganization
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.FolderID,
		&i.CustomOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSharedTrackOrganization = `-- name: UpdateSharedTrackOrganization :one
UPDATE user_shared_track_organization
SET folder_id = ?,
    custom_order = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = ? AND track_id = ?
RETURNING id, user_id, track_id, folder_id, custom_order, created_at, updated_at
`

type UpdateSharedTrackOrganizationParams struct {
	FolderID    sql.NullInt64 `json:"folder_id"`
	CustomOrder int64         `json:"custom_order"`
	UserID      int64         `json:"user_id"`
	TrackID     int64         `json:"track_id"`
}

func (q *Queries) UpdateSharedTrackOrganization(ctx context.Context, arg UpdateSharedTrackOrganizationParams) (UserSharedTrackOrganization, error) {
	row := q.db.QueryRowContext(ctx, updateSharedTrackOrganization,
		arg.FolderID,
		arg.CustomOrder,
		arg.UserID,
		arg.TrackID,
	)
	var i UserSharedTrackOrganization
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TrackID,
		&i.FolderID,
		&i.CustomOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertSharedProjectOrganization = `-- name: UpsertSharedProjectOrganization :one
INSERT INTO user_shared_project_organization (
    user_id,
    project_id,
    folder_id,
    custom_order
) VALUES (?, ?, ?, ?)
ON CONFLICT(user_id, project_id) DO UPDATE SET
    folder_id = excluded.folder_id,
    custom_order = excluded.custom_order,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, user_id, project_id, folder_id, custom_order, created_at, updated_at
`

type UpsertSharedProjectOrganizationParams struct {
	UserID      int64         `json:"user_id"`
	ProjectID   int64         `json:"project_id"`
	FolderID    sql.NullInt64 `json:"folder_id"`
	CustomOrder int64         `json:"custom_order"`
}

func (q *Queries) UpsertSharedProjectOrganization(ctx context.Context, arg UpsertSharedProjectOrganizationParams) (UserSharedProjectOrganization, error) {
	row := q.db.QueryRowContext(ctx, upsertSharedProjectOrganization,
		arg.UserID,
		arg.ProjectID,
		arg.FolderID,
		arg.CustomOrder,
	)
	var i UserSharedProjectOrganization
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.FolderID,
		&i.CustomOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertSharedTrackOrganization = `-- name: UpsertSharedTrackOrganization :one
INSERT INTO user_shared_track_organization (
    user_id,
    track_id,
    folder_id,
    custom_order
) VALUES (?, ?, ?, ?)
ON CONFLICT(user_id, track_id) DO UPDATE SET
    folder_id = excluded.folder_id,
    custom_order = excluded.custom_order,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, user_id, track_id, folder_id, custom_order, created_at, updated_at
`

type UpsertSharedTrackOrganizationParams struct {
	UserID      int64         `json:"user_id"`
	TrackID     int64         `json:"track_id"`
	FolderID    sql.NullInt64 `json:"folder_id"`
	CustomOrder int64         `json:"custom_order"`
}

func (q *Queries) UpsertSharedTrackOrganization(ctx context.Context, arg UpsertSharedTrackOrganizationParams) (UserSharedTrackOrganization, error) {
	row := q.db.QueryRowContext(ctx, upsertSharedTrackOrganization,
		arg.UserID,
		arg.TrackID,
		arg.FolderID,
		arg.CustomOrder,
	)
	var i UserSharedTrackOrganization
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TrackID,
		&i.FolderID,
		&i.CustomOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
