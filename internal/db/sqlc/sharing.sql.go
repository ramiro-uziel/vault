// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sharing.sql

package db

import (
	"context"
	"database/sql"
)

const createFederationToken = `-- name: CreateFederationToken :one

INSERT INTO federation_tokens (
    token, origin_instance_url, origin_share_token, local_user_id,
    resource_type, resource_id, remote_user_id, remote_username, expires_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, token, origin_instance_url, origin_share_token, local_user_id, resource_type, resource_id, remote_user_id, remote_username, expires_at, last_used_at, created_at, updated_at
`

type CreateFederationTokenParams struct {
	Token             string         `json:"token"`
	OriginInstanceUrl string         `json:"origin_instance_url"`
	OriginShareToken  string         `json:"origin_share_token"`
	LocalUserID       int64          `json:"local_user_id"`
	ResourceType      string         `json:"resource_type"`
	ResourceID        int64          `json:"resource_id"`
	RemoteUserID      sql.NullInt64  `json:"remote_user_id"`
	RemoteUsername    sql.NullString `json:"remote_username"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
}

// FEDERATION TOKENS
func (q *Queries) CreateFederationToken(ctx context.Context, arg CreateFederationTokenParams) (FederationToken, error) {
	row := q.db.QueryRowContext(ctx, createFederationToken,
		arg.Token,
		arg.OriginInstanceUrl,
		arg.OriginShareToken,
		arg.LocalUserID,
		arg.ResourceType,
		arg.ResourceID,
		arg.RemoteUserID,
		arg.RemoteUsername,
		arg.ExpiresAt,
	)
	var i FederationToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.OriginInstanceUrl,
		&i.OriginShareToken,
		&i.LocalUserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.RemoteUserID,
		&i.RemoteUsername,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectShareToken = `-- name: CreateProjectShareToken :one

INSERT INTO project_share_tokens (
    token, user_id, project_id, expires_at, max_access_count,
    allow_editing, allow_downloads, password_hash, visibility_type
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, token, user_id, project_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at
`

type CreateProjectShareTokenParams struct {
	Token          string         `json:"token"`
	UserID         int64          `json:"user_id"`
	ProjectID      int64          `json:"project_id"`
	ExpiresAt      sql.NullTime   `json:"expires_at"`
	MaxAccessCount sql.NullInt64  `json:"max_access_count"`
	AllowEditing   bool           `json:"allow_editing"`
	AllowDownloads bool           `json:"allow_downloads"`
	PasswordHash   sql.NullString `json:"password_hash"`
	VisibilityType string         `json:"visibility_type"`
}

// PROJECT SHARE TOKENS
func (q *Queries) CreateProjectShareToken(ctx context.Context, arg CreateProjectShareTokenParams) (ProjectShareToken, error) {
	row := q.db.QueryRowContext(ctx, createProjectShareToken,
		arg.Token,
		arg.UserID,
		arg.ProjectID,
		arg.ExpiresAt,
		arg.MaxAccessCount,
		arg.AllowEditing,
		arg.AllowDownloads,
		arg.PasswordHash,
		arg.VisibilityType,
	)
	var i ProjectShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.ProjectID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createShareAccess = `-- name: CreateShareAccess :one

INSERT INTO share_access (
    share_type, share_token_id, user_id, user_instance_url,
    federation_token_id, can_edit, can_download
)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, share_type, share_token_id, user_id, user_instance_url, federation_token_id, accepted_at, last_accessed_at, access_count, can_edit, can_download
`

type CreateShareAccessParams struct {
	ShareType         string         `json:"share_type"`
	ShareTokenID      int64          `json:"share_token_id"`
	UserID            int64          `json:"user_id"`
	UserInstanceUrl   sql.NullString `json:"user_instance_url"`
	FederationTokenID sql.NullInt64  `json:"federation_token_id"`
	CanEdit           bool           `json:"can_edit"`
	CanDownload       bool           `json:"can_download"`
}

// SHARE ACCESS
func (q *Queries) CreateShareAccess(ctx context.Context, arg CreateShareAccessParams) (ShareAccess, error) {
	row := q.db.QueryRowContext(ctx, createShareAccess,
		arg.ShareType,
		arg.ShareTokenID,
		arg.UserID,
		arg.UserInstanceUrl,
		arg.FederationTokenID,
		arg.CanEdit,
		arg.CanDownload,
	)
	var i ShareAccess
	err := row.Scan(
		&i.ID,
		&i.ShareType,
		&i.ShareTokenID,
		&i.UserID,
		&i.UserInstanceUrl,
		&i.FederationTokenID,
		&i.AcceptedAt,
		&i.LastAccessedAt,
		&i.AccessCount,
		&i.CanEdit,
		&i.CanDownload,
	)
	return i, err
}

const createShareToken = `-- name: CreateShareToken :one

INSERT INTO share_tokens (
    token, user_id, track_id, version_id, expires_at, max_access_count,
    allow_editing, allow_downloads, password_hash, visibility_type
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, token, user_id, track_id, version_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at
`

type CreateShareTokenParams struct {
	Token          string         `json:"token"`
	UserID         int64          `json:"user_id"`
	TrackID        int64          `json:"track_id"`
	VersionID      sql.NullInt64  `json:"version_id"`
	ExpiresAt      sql.NullTime   `json:"expires_at"`
	MaxAccessCount sql.NullInt64  `json:"max_access_count"`
	AllowEditing   bool           `json:"allow_editing"`
	AllowDownloads bool           `json:"allow_downloads"`
	PasswordHash   sql.NullString `json:"password_hash"`
	VisibilityType string         `json:"visibility_type"`
}

// TRACK SHARE TOKENS
func (q *Queries) CreateShareToken(ctx context.Context, arg CreateShareTokenParams) (ShareToken, error) {
	row := q.db.QueryRowContext(ctx, createShareToken,
		arg.Token,
		arg.UserID,
		arg.TrackID,
		arg.VersionID,
		arg.ExpiresAt,
		arg.MaxAccessCount,
		arg.AllowEditing,
		arg.AllowDownloads,
		arg.PasswordHash,
		arg.VisibilityType,
	)
	var i ShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.TrackID,
		&i.VersionID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserProjectShare = `-- name: CreateUserProjectShare :one

INSERT INTO user_project_shares (project_id, shared_by, shared_to, can_edit, can_download)
VALUES (?, ?, ?, ?, ?)
RETURNING id, project_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at
`

type CreateUserProjectShareParams struct {
	ProjectID   int64 `json:"project_id"`
	SharedBy    int64 `json:"shared_by"`
	SharedTo    int64 `json:"shared_to"`
	CanEdit     bool  `json:"can_edit"`
	CanDownload bool  `json:"can_download"`
}

// USER-TO-USER SHARING (SAME INSTANCE)
func (q *Queries) CreateUserProjectShare(ctx context.Context, arg CreateUserProjectShareParams) (UserProjectShare, error) {
	row := q.db.QueryRowContext(ctx, createUserProjectShare,
		arg.ProjectID,
		arg.SharedBy,
		arg.SharedTo,
		arg.CanEdit,
		arg.CanDownload,
	)
	var i UserProjectShare
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SharedBy,
		&i.SharedTo,
		&i.CanEdit,
		&i.CanDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserTrackShare = `-- name: CreateUserTrackShare :one
INSERT INTO user_track_shares (track_id, shared_by, shared_to, can_edit, can_download)
VALUES (?, ?, ?, ?, ?)
RETURNING id, track_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at
`

type CreateUserTrackShareParams struct {
	TrackID     int64 `json:"track_id"`
	SharedBy    int64 `json:"shared_by"`
	SharedTo    int64 `json:"shared_to"`
	CanEdit     bool  `json:"can_edit"`
	CanDownload bool  `json:"can_download"`
}

func (q *Queries) CreateUserTrackShare(ctx context.Context, arg CreateUserTrackShareParams) (UserTrackShare, error) {
	row := q.db.QueryRowContext(ctx, createUserTrackShare,
		arg.TrackID,
		arg.SharedBy,
		arg.SharedTo,
		arg.CanEdit,
		arg.CanDownload,
	)
	var i UserTrackShare
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.SharedBy,
		&i.SharedTo,
		&i.CanEdit,
		&i.CanDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWebSocketSession = `-- name: CreateWebSocketSession :one

INSERT INTO websocket_sessions (
    session_id, user_id, user_instance_url, resource_type, resource_id
)
VALUES (?, ?, ?, ?, ?)
RETURNING id, session_id, user_id, user_instance_url, resource_type, resource_id, connected_at, last_heartbeat_at
`

type CreateWebSocketSessionParams struct {
	SessionID       string         `json:"session_id"`
	UserID          int64          `json:"user_id"`
	UserInstanceUrl sql.NullString `json:"user_instance_url"`
	ResourceType    string         `json:"resource_type"`
	ResourceID      string         `json:"resource_id"`
}

// WEBSOCKET SESSIONS
func (q *Queries) CreateWebSocketSession(ctx context.Context, arg CreateWebSocketSessionParams) (WebsocketSession, error) {
	row := q.db.QueryRowContext(ctx, createWebSocketSession,
		arg.SessionID,
		arg.UserID,
		arg.UserInstanceUrl,
		arg.ResourceType,
		arg.ResourceID,
	)
	var i WebsocketSession
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.UserInstanceUrl,
		&i.ResourceType,
		&i.ResourceID,
		&i.ConnectedAt,
		&i.LastHeartbeatAt,
	)
	return i, err
}

const deleteExpiredFederationTokens = `-- name: DeleteExpiredFederationTokens :exec
DELETE FROM federation_tokens
WHERE expires_at IS NOT NULL AND expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredFederationTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredFederationTokens)
	return err
}

const deleteFederationToken = `-- name: DeleteFederationToken :exec
DELETE FROM federation_tokens
WHERE id = ? AND local_user_id = ?
`

type DeleteFederationTokenParams struct {
	ID          int64 `json:"id"`
	LocalUserID int64 `json:"local_user_id"`
}

func (q *Queries) DeleteFederationToken(ctx context.Context, arg DeleteFederationTokenParams) error {
	_, err := q.db.ExecContext(ctx, deleteFederationToken, arg.ID, arg.LocalUserID)
	return err
}

const deleteFederationTokenByToken = `-- name: DeleteFederationTokenByToken :exec
DELETE FROM federation_tokens
WHERE token = ?
`

func (q *Queries) DeleteFederationTokenByToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteFederationTokenByToken, token)
	return err
}

const deleteProjectShareToken = `-- name: DeleteProjectShareToken :exec
DELETE FROM project_share_tokens
WHERE id = ? AND user_id = ?
`

type DeleteProjectShareTokenParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteProjectShareToken(ctx context.Context, arg DeleteProjectShareTokenParams) error {
	_, err := q.db.ExecContext(ctx, deleteProjectShareToken, arg.ID, arg.UserID)
	return err
}

const deleteProjectShareTokenByProject = `-- name: DeleteProjectShareTokenByProject :exec
DELETE FROM project_share_tokens
WHERE project_id = ? AND user_id = ?
`

type DeleteProjectShareTokenByProjectParams struct {
	ProjectID int64 `json:"project_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) DeleteProjectShareTokenByProject(ctx context.Context, arg DeleteProjectShareTokenByProjectParams) error {
	_, err := q.db.ExecContext(ctx, deleteProjectShareTokenByProject, arg.ProjectID, arg.UserID)
	return err
}

const deleteShareAccess = `-- name: DeleteShareAccess :exec
DELETE FROM share_access
WHERE id = ? AND user_id = ?
`

type DeleteShareAccessParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteShareAccess(ctx context.Context, arg DeleteShareAccessParams) error {
	_, err := q.db.ExecContext(ctx, deleteShareAccess, arg.ID, arg.UserID)
	return err
}

const deleteShareAccessByShare = `-- name: DeleteShareAccessByShare :exec
DELETE FROM share_access
WHERE share_type = ? AND share_token_id = ?
`

type DeleteShareAccessByShareParams struct {
	ShareType    string `json:"share_type"`
	ShareTokenID int64  `json:"share_token_id"`
}

func (q *Queries) DeleteShareAccessByShare(ctx context.Context, arg DeleteShareAccessByShareParams) error {
	_, err := q.db.ExecContext(ctx, deleteShareAccessByShare, arg.ShareType, arg.ShareTokenID)
	return err
}

const deleteShareToken = `-- name: DeleteShareToken :exec
DELETE FROM share_tokens
WHERE id = ? AND user_id = ?
`

type DeleteShareTokenParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteShareToken(ctx context.Context, arg DeleteShareTokenParams) error {
	_, err := q.db.ExecContext(ctx, deleteShareToken, arg.ID, arg.UserID)
	return err
}

const deleteShareTokenByTrack = `-- name: DeleteShareTokenByTrack :exec
DELETE FROM share_tokens
WHERE track_id = ? AND user_id = ?
`

type DeleteShareTokenByTrackParams struct {
	TrackID int64 `json:"track_id"`
	UserID  int64 `json:"user_id"`
}

func (q *Queries) DeleteShareTokenByTrack(ctx context.Context, arg DeleteShareTokenByTrackParams) error {
	_, err := q.db.ExecContext(ctx, deleteShareTokenByTrack, arg.TrackID, arg.UserID)
	return err
}

const deleteStaleWebSocketSessions = `-- name: DeleteStaleWebSocketSessions :exec
DELETE FROM websocket_sessions
WHERE last_heartbeat_at < datetime('now', '-5 minutes')
`

func (q *Queries) DeleteStaleWebSocketSessions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteStaleWebSocketSessions)
	return err
}

const deleteUserProjectShare = `-- name: DeleteUserProjectShare :exec
DELETE FROM user_project_shares
WHERE id = ? AND shared_by = ?
`

type DeleteUserProjectShareParams struct {
	ID       int64 `json:"id"`
	SharedBy int64 `json:"shared_by"`
}

func (q *Queries) DeleteUserProjectShare(ctx context.Context, arg DeleteUserProjectShareParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserProjectShare, arg.ID, arg.SharedBy)
	return err
}

const deleteUserProjectShareByID = `-- name: DeleteUserProjectShareByID :exec
DELETE FROM user_project_shares
WHERE project_id = ? AND shared_to = ?
`

type DeleteUserProjectShareByIDParams struct {
	ProjectID int64 `json:"project_id"`
	SharedTo  int64 `json:"shared_to"`
}

func (q *Queries) DeleteUserProjectShareByID(ctx context.Context, arg DeleteUserProjectShareByIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserProjectShareByID, arg.ProjectID, arg.SharedTo)
	return err
}

const deleteUserTrackShare = `-- name: DeleteUserTrackShare :exec
DELETE FROM user_track_shares
WHERE id = ? AND shared_by = ?
`

type DeleteUserTrackShareParams struct {
	ID       int64 `json:"id"`
	SharedBy int64 `json:"shared_by"`
}

func (q *Queries) DeleteUserTrackShare(ctx context.Context, arg DeleteUserTrackShareParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserTrackShare, arg.ID, arg.SharedBy)
	return err
}

const deleteUserTrackShareByID = `-- name: DeleteUserTrackShareByID :exec
DELETE FROM user_track_shares
WHERE track_id = ? AND shared_to = ?
`

type DeleteUserTrackShareByIDParams struct {
	TrackID  int64 `json:"track_id"`
	SharedTo int64 `json:"shared_to"`
}

func (q *Queries) DeleteUserTrackShareByID(ctx context.Context, arg DeleteUserTrackShareByIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserTrackShareByID, arg.TrackID, arg.SharedTo)
	return err
}

const deleteUserTrackShareByShareID = `-- name: DeleteUserTrackShareByShareID :exec
DELETE FROM user_track_shares
WHERE id = ?
`

func (q *Queries) DeleteUserTrackShareByShareID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserTrackShareByShareID, id)
	return err
}

const deleteWebSocketSession = `-- name: DeleteWebSocketSession :exec
DELETE FROM websocket_sessions
WHERE session_id = ?
`

func (q *Queries) DeleteWebSocketSession(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, deleteWebSocketSession, sessionID)
	return err
}

const getFederationToken = `-- name: GetFederationToken :one
SELECT id, token, origin_instance_url, origin_share_token, local_user_id, resource_type, resource_id, remote_user_id, remote_username, expires_at, last_used_at, created_at, updated_at FROM federation_tokens
WHERE token = ?
`

func (q *Queries) GetFederationToken(ctx context.Context, token string) (FederationToken, error) {
	row := q.db.QueryRowContext(ctx, getFederationToken, token)
	var i FederationToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.OriginInstanceUrl,
		&i.OriginShareToken,
		&i.LocalUserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.RemoteUserID,
		&i.RemoteUsername,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFederationTokenByID = `-- name: GetFederationTokenByID :one
SELECT id, token, origin_instance_url, origin_share_token, local_user_id, resource_type, resource_id, remote_user_id, remote_username, expires_at, last_used_at, created_at, updated_at FROM federation_tokens
WHERE id = ?
`

func (q *Queries) GetFederationTokenByID(ctx context.Context, id int64) (FederationToken, error) {
	row := q.db.QueryRowContext(ctx, getFederationTokenByID, id)
	var i FederationToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.OriginInstanceUrl,
		&i.OriginShareToken,
		&i.LocalUserID,
		&i.ResourceType,
		&i.ResourceID,
		&i.RemoteUserID,
		&i.RemoteUsername,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInstanceConfig = `-- name: GetInstanceConfig :one

SELECT id, instance_url, instance_name, allow_federation, allow_public_shares, created_at, updated_at FROM instance_config
WHERE id = 1
`

// INSTANCE CONFIGURATION
func (q *Queries) GetInstanceConfig(ctx context.Context) (InstanceConfig, error) {
	row := q.db.QueryRowContext(ctx, getInstanceConfig)
	var i InstanceConfig
	err := row.Scan(
		&i.ID,
		&i.InstanceUrl,
		&i.InstanceName,
		&i.AllowFederation,
		&i.AllowPublicShares,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectShareToken = `-- name: GetProjectShareToken :one
SELECT id, token, user_id, project_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM project_share_tokens
WHERE token = ?
`

func (q *Queries) GetProjectShareToken(ctx context.Context, token string) (ProjectShareToken, error) {
	row := q.db.QueryRowContext(ctx, getProjectShareToken, token)
	var i ProjectShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.ProjectID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectShareTokenByID = `-- name: GetProjectShareTokenByID :one
SELECT id, token, user_id, project_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM project_share_tokens
WHERE id = ? AND user_id = ?
`

type GetProjectShareTokenByIDParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetProjectShareTokenByID(ctx context.Context, arg GetProjectShareTokenByIDParams) (ProjectShareToken, error) {
	row := q.db.QueryRowContext(ctx, getProjectShareTokenByID, arg.ID, arg.UserID)
	var i ProjectShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.ProjectID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectShareTokenByProject = `-- name: GetProjectShareTokenByProject :one
SELECT id, token, user_id, project_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM project_share_tokens
WHERE project_id = ? AND user_id = ?
LIMIT 1
`

type GetProjectShareTokenByProjectParams struct {
	ProjectID int64 `json:"project_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) GetProjectShareTokenByProject(ctx context.Context, arg GetProjectShareTokenByProjectParams) (ProjectShareToken, error) {
	row := q.db.QueryRowContext(ctx, getProjectShareTokenByProject, arg.ProjectID, arg.UserID)
	var i ProjectShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.ProjectID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublicProjects = `-- name: GetPublicProjects :many
SELECT id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed FROM projects
WHERE visibility_status = 'public'
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetPublicProjectsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetPublicProjects(ctx context.Context, arg GetPublicProjectsParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getPublicProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.QualityOverride,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublicID,
			&i.CoverArtPath,
			&i.CoverArtMime,
			&i.CoverArtUpdatedAt,
			&i.AuthorOverride,
			&i.FolderID,
			&i.FolderAddedAt,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
			&i.CustomOrder,
			&i.CoverProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicTracks = `-- name: GetPublicTracks :many
SELECT id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users FROM tracks
WHERE visibility_status = 'public'
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetPublicTracksParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetPublicTracks(ctx context.Context, arg GetPublicTracksParams) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, getPublicTracks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.ActiveVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackOrder,
			&i.Key,
			&i.Bpm,
			&i.PublicID,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShareAccess = `-- name: GetShareAccess :one
SELECT id, share_type, share_token_id, user_id, user_instance_url, federation_token_id, accepted_at, last_accessed_at, access_count, can_edit, can_download FROM share_access
WHERE share_type = ? AND share_token_id = ? AND user_id = ? AND COALESCE(user_instance_url, '') = COALESCE(?, '')
`

type GetShareAccessParams struct {
	ShareType       string         `json:"share_type"`
	ShareTokenID    int64          `json:"share_token_id"`
	UserID          int64          `json:"user_id"`
	UserInstanceUrl sql.NullString `json:"user_instance_url"`
}

func (q *Queries) GetShareAccess(ctx context.Context, arg GetShareAccessParams) (ShareAccess, error) {
	row := q.db.QueryRowContext(ctx, getShareAccess,
		arg.ShareType,
		arg.ShareTokenID,
		arg.UserID,
		arg.UserInstanceUrl,
	)
	var i ShareAccess
	err := row.Scan(
		&i.ID,
		&i.ShareType,
		&i.ShareTokenID,
		&i.UserID,
		&i.UserInstanceUrl,
		&i.FederationTokenID,
		&i.AcceptedAt,
		&i.LastAccessedAt,
		&i.AccessCount,
		&i.CanEdit,
		&i.CanDownload,
	)
	return i, err
}

const getShareToken = `-- name: GetShareToken :one
SELECT id, token, user_id, track_id, version_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM share_tokens
WHERE token = ?
`

func (q *Queries) GetShareToken(ctx context.Context, token string) (ShareToken, error) {
	row := q.db.QueryRowContext(ctx, getShareToken, token)
	var i ShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.TrackID,
		&i.VersionID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShareTokenByID = `-- name: GetShareTokenByID :one
SELECT id, token, user_id, track_id, version_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM share_tokens
WHERE id = ? AND user_id = ?
`

type GetShareTokenByIDParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetShareTokenByID(ctx context.Context, arg GetShareTokenByIDParams) (ShareToken, error) {
	row := q.db.QueryRowContext(ctx, getShareTokenByID, arg.ID, arg.UserID)
	var i ShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.TrackID,
		&i.VersionID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShareTokenByTrack = `-- name: GetShareTokenByTrack :one
SELECT id, token, user_id, track_id, version_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM share_tokens
WHERE track_id = ? AND user_id = ?
LIMIT 1
`

type GetShareTokenByTrackParams struct {
	TrackID int64 `json:"track_id"`
	UserID  int64 `json:"user_id"`
}

func (q *Queries) GetShareTokenByTrack(ctx context.Context, arg GetShareTokenByTrackParams) (ShareToken, error) {
	row := q.db.QueryRowContext(ctx, getShareTokenByTrack, arg.TrackID, arg.UserID)
	var i ShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.TrackID,
		&i.VersionID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserProjectShare = `-- name: GetUserProjectShare :one
SELECT id, project_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at FROM user_project_shares
WHERE project_id = ? AND shared_to = ?
`

type GetUserProjectShareParams struct {
	ProjectID int64 `json:"project_id"`
	SharedTo  int64 `json:"shared_to"`
}

func (q *Queries) GetUserProjectShare(ctx context.Context, arg GetUserProjectShareParams) (UserProjectShare, error) {
	row := q.db.QueryRowContext(ctx, getUserProjectShare, arg.ProjectID, arg.SharedTo)
	var i UserProjectShare
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SharedBy,
		&i.SharedTo,
		&i.CanEdit,
		&i.CanDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserTrackShare = `-- name: GetUserTrackShare :one
SELECT id, track_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at FROM user_track_shares
WHERE track_id = ? AND shared_to = ?
`

type GetUserTrackShareParams struct {
	TrackID  int64 `json:"track_id"`
	SharedTo int64 `json:"shared_to"`
}

func (q *Queries) GetUserTrackShare(ctx context.Context, arg GetUserTrackShareParams) (UserTrackShare, error) {
	row := q.db.QueryRowContext(ctx, getUserTrackShare, arg.TrackID, arg.SharedTo)
	var i UserTrackShare
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.SharedBy,
		&i.SharedTo,
		&i.CanEdit,
		&i.CanDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserTrackShareByID = `-- name: GetUserTrackShareByID :one
SELECT id, track_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at FROM user_track_shares
WHERE id = ?
`

func (q *Queries) GetUserTrackShareByID(ctx context.Context, id int64) (UserTrackShare, error) {
	row := q.db.QueryRowContext(ctx, getUserTrackShareByID, id)
	var i UserTrackShare
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.SharedBy,
		&i.SharedTo,
		&i.CanEdit,
		&i.CanDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWebSocketSession = `-- name: GetWebSocketSession :one
SELECT id, session_id, user_id, user_instance_url, resource_type, resource_id, connected_at, last_heartbeat_at FROM websocket_sessions
WHERE session_id = ?
`

func (q *Queries) GetWebSocketSession(ctx context.Context, sessionID string) (WebsocketSession, error) {
	row := q.db.QueryRowContext(ctx, getWebSocketSession, sessionID)
	var i WebsocketSession
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.UserInstanceUrl,
		&i.ResourceType,
		&i.ResourceID,
		&i.ConnectedAt,
		&i.LastHeartbeatAt,
	)
	return i, err
}

const incrementAccessCount = `-- name: IncrementAccessCount :exec
UPDATE share_tokens
SET current_access_count = current_access_count + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) IncrementAccessCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementAccessCount, id)
	return err
}

const incrementProjectAccessCount = `-- name: IncrementProjectAccessCount :exec
UPDATE project_share_tokens
SET current_access_count = current_access_count + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) IncrementProjectAccessCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementProjectAccessCount, id)
	return err
}

const listFederationTokensByOrigin = `-- name: ListFederationTokensByOrigin :many
SELECT id, token, origin_instance_url, origin_share_token, local_user_id, resource_type, resource_id, remote_user_id, remote_username, expires_at, last_used_at, created_at, updated_at FROM federation_tokens
WHERE origin_instance_url = ? AND local_user_id = ?
ORDER BY created_at DESC
`

type ListFederationTokensByOriginParams struct {
	OriginInstanceUrl string `json:"origin_instance_url"`
	LocalUserID       int64  `json:"local_user_id"`
}

func (q *Queries) ListFederationTokensByOrigin(ctx context.Context, arg ListFederationTokensByOriginParams) ([]FederationToken, error) {
	rows, err := q.db.QueryContext(ctx, listFederationTokensByOrigin, arg.OriginInstanceUrl, arg.LocalUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FederationToken{}
	for rows.Next() {
		var i FederationToken
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.OriginInstanceUrl,
			&i.OriginShareToken,
			&i.LocalUserID,
			&i.ResourceType,
			&i.ResourceID,
			&i.RemoteUserID,
			&i.RemoteUsername,
			&i.ExpiresAt,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFederationTokensByUser = `-- name: ListFederationTokensByUser :many
SELECT id, token, origin_instance_url, origin_share_token, local_user_id, resource_type, resource_id, remote_user_id, remote_username, expires_at, last_used_at, created_at, updated_at FROM federation_tokens
WHERE local_user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListFederationTokensByUser(ctx context.Context, localUserID int64) ([]FederationToken, error) {
	rows, err := q.db.QueryContext(ctx, listFederationTokensByUser, localUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FederationToken{}
	for rows.Next() {
		var i FederationToken
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.OriginInstanceUrl,
			&i.OriginShareToken,
			&i.LocalUserID,
			&i.ResourceType,
			&i.ResourceID,
			&i.RemoteUserID,
			&i.RemoteUsername,
			&i.ExpiresAt,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectShareTokensByProject = `-- name: ListProjectShareTokensByProject :many
SELECT id, token, user_id, project_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM project_share_tokens
WHERE project_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListProjectShareTokensByProject(ctx context.Context, projectID int64) ([]ProjectShareToken, error) {
	rows, err := q.db.QueryContext(ctx, listProjectShareTokensByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectShareToken{}
	for rows.Next() {
		var i ProjectShareToken
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.UserID,
			&i.ProjectID,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.CurrentAccessCount,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.VisibilityType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectShareTokensByUser = `-- name: ListProjectShareTokensByUser :many
SELECT id, token, user_id, project_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM project_share_tokens
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListProjectShareTokensByUser(ctx context.Context, userID int64) ([]ProjectShareToken, error) {
	rows, err := q.db.QueryContext(ctx, listProjectShareTokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectShareToken{}
	for rows.Next() {
		var i ProjectShareToken
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.UserID,
			&i.ProjectID,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.CurrentAccessCount,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.VisibilityType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectShareTokensWithProjectInfo = `-- name: ListProjectShareTokensWithProjectInfo :many
SELECT
    pst.id, pst.token, pst.user_id, pst.project_id, pst.expires_at, pst.max_access_count, pst.current_access_count, pst.allow_editing, pst.allow_downloads, pst.password_hash, pst.visibility_type, pst.created_at, pst.updated_at,
    p.public_id as project_public_id
FROM project_share_tokens pst
JOIN projects p ON pst.project_id = p.id
WHERE pst.user_id = ?
ORDER BY pst.created_at DESC
`

type ListProjectShareTokensWithProjectInfoRow struct {
	ID                 int64          `json:"id"`
	Token              string         `json:"token"`
	UserID             int64          `json:"user_id"`
	ProjectID          int64          `json:"project_id"`
	ExpiresAt          sql.NullTime   `json:"expires_at"`
	MaxAccessCount     sql.NullInt64  `json:"max_access_count"`
	CurrentAccessCount sql.NullInt64  `json:"current_access_count"`
	AllowEditing       bool           `json:"allow_editing"`
	AllowDownloads     bool           `json:"allow_downloads"`
	PasswordHash       sql.NullString `json:"password_hash"`
	VisibilityType     string         `json:"visibility_type"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
	ProjectPublicID    string         `json:"project_public_id"`
}

func (q *Queries) ListProjectShareTokensWithProjectInfo(ctx context.Context, userID int64) ([]ListProjectShareTokensWithProjectInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectShareTokensWithProjectInfo, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectShareTokensWithProjectInfoRow{}
	for rows.Next() {
		var i ListProjectShareTokensWithProjectInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.UserID,
			&i.ProjectID,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.CurrentAccessCount,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.VisibilityType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsSharedByUser = `-- name: ListProjectsSharedByUser :many
SELECT id, project_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at FROM user_project_shares
WHERE shared_by = ?
ORDER BY created_at DESC
`

func (q *Queries) ListProjectsSharedByUser(ctx context.Context, sharedBy int64) ([]UserProjectShare, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsSharedByUser, sharedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserProjectShare{}
	for rows.Next() {
		var i UserProjectShare
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SharedBy,
			&i.SharedTo,
			&i.CanEdit,
			&i.CanDownload,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsSharedWithUser = `-- name: ListProjectsSharedWithUser :many
SELECT DISTINCT p.id, p.user_id, p.name, p.description, p.quality_override, p.created_at, p.updated_at, p.public_id, p.cover_art_path, p.cover_art_mime, p.cover_art_updated_at, p.author_override, p.folder_id, p.folder_added_at, p.notes, p.notes_author_name, p.notes_updated_at, p.visibility_status, p.allow_editing, p.allow_downloads, p.password_hash, p.origin_instance_url, p.shared_with_instance_users, p.custom_order, p.cover_processed FROM projects p
JOIN user_project_shares ups ON p.id = ups.project_id
WHERE ups.shared_to = ?
ORDER BY p.created_at DESC
`

func (q *Queries) ListProjectsSharedWithUser(ctx context.Context, sharedTo int64) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsSharedWithUser, sharedTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.QualityOverride,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublicID,
			&i.CoverArtPath,
			&i.CoverArtMime,
			&i.CoverArtUpdatedAt,
			&i.AuthorOverride,
			&i.FolderID,
			&i.FolderAddedAt,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
			&i.CustomOrder,
			&i.CoverProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShareAccessByShare = `-- name: ListShareAccessByShare :many
SELECT id, share_type, share_token_id, user_id, user_instance_url, federation_token_id, accepted_at, last_accessed_at, access_count, can_edit, can_download FROM share_access
WHERE share_type = ? AND share_token_id = ?
ORDER BY accepted_at DESC
`

type ListShareAccessByShareParams struct {
	ShareType    string `json:"share_type"`
	ShareTokenID int64  `json:"share_token_id"`
}

func (q *Queries) ListShareAccessByShare(ctx context.Context, arg ListShareAccessByShareParams) ([]ShareAccess, error) {
	rows, err := q.db.QueryContext(ctx, listShareAccessByShare, arg.ShareType, arg.ShareTokenID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareAccess{}
	for rows.Next() {
		var i ShareAccess
		if err := rows.Scan(
			&i.ID,
			&i.ShareType,
			&i.ShareTokenID,
			&i.UserID,
			&i.UserInstanceUrl,
			&i.FederationTokenID,
			&i.AcceptedAt,
			&i.LastAccessedAt,
			&i.AccessCount,
			&i.CanEdit,
			&i.CanDownload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShareAccessByUser = `-- name: ListShareAccessByUser :many
SELECT id, share_type, share_token_id, user_id, user_instance_url, federation_token_id, accepted_at, last_accessed_at, access_count, can_edit, can_download FROM share_access
WHERE user_id = ?
ORDER BY accepted_at DESC
`

func (q *Queries) ListShareAccessByUser(ctx context.Context, userID int64) ([]ShareAccess, error) {
	rows, err := q.db.QueryContext(ctx, listShareAccessByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareAccess{}
	for rows.Next() {
		var i ShareAccess
		if err := rows.Scan(
			&i.ID,
			&i.ShareType,
			&i.ShareTokenID,
			&i.UserID,
			&i.UserInstanceUrl,
			&i.FederationTokenID,
			&i.AcceptedAt,
			&i.LastAccessedAt,
			&i.AccessCount,
			&i.CanEdit,
			&i.CanDownload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShareTokensByTrack = `-- name: ListShareTokensByTrack :many
SELECT id, token, user_id, track_id, version_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM share_tokens
WHERE track_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListShareTokensByTrack(ctx context.Context, trackID int64) ([]ShareToken, error) {
	rows, err := q.db.QueryContext(ctx, listShareTokensByTrack, trackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareToken{}
	for rows.Next() {
		var i ShareToken
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.UserID,
			&i.TrackID,
			&i.VersionID,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.CurrentAccessCount,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.VisibilityType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShareTokensByUser = `-- name: ListShareTokensByUser :many
SELECT id, token, user_id, track_id, version_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at FROM share_tokens
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListShareTokensByUser(ctx context.Context, userID int64) ([]ShareToken, error) {
	rows, err := q.db.QueryContext(ctx, listShareTokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareToken{}
	for rows.Next() {
		var i ShareToken
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.UserID,
			&i.TrackID,
			&i.VersionID,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.CurrentAccessCount,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.VisibilityType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShareTokensWithTrackInfo = `-- name: ListShareTokensWithTrackInfo :many
SELECT
    st.id, st.token, st.user_id, st.track_id, st.version_id, st.expires_at, st.max_access_count, st.current_access_count, st.allow_editing, st.allow_downloads, st.password_hash, st.visibility_type, st.created_at, st.updated_at,
    t.public_id as track_public_id
FROM share_tokens st
JOIN tracks t ON st.track_id = t.id
WHERE st.user_id = ?
ORDER BY st.created_at DESC
`

type ListShareTokensWithTrackInfoRow struct {
	ID                 int64          `json:"id"`
	Token              string         `json:"token"`
	UserID             int64          `json:"user_id"`
	TrackID            int64          `json:"track_id"`
	VersionID          sql.NullInt64  `json:"version_id"`
	ExpiresAt          sql.NullTime   `json:"expires_at"`
	MaxAccessCount     sql.NullInt64  `json:"max_access_count"`
	CurrentAccessCount sql.NullInt64  `json:"current_access_count"`
	AllowEditing       bool           `json:"allow_editing"`
	AllowDownloads     bool           `json:"allow_downloads"`
	PasswordHash       sql.NullString `json:"password_hash"`
	VisibilityType     string         `json:"visibility_type"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
	TrackPublicID      string         `json:"track_public_id"`
}

func (q *Queries) ListShareTokensWithTrackInfo(ctx context.Context, userID int64) ([]ListShareTokensWithTrackInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, listShareTokensWithTrackInfo, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShareTokensWithTrackInfoRow{}
	for rows.Next() {
		var i ListShareTokensWithTrackInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.UserID,
			&i.TrackID,
			&i.VersionID,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.CurrentAccessCount,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.VisibilityType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackPublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksSharedByUser = `-- name: ListTracksSharedByUser :many
SELECT id, track_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at FROM user_track_shares
WHERE shared_by = ?
ORDER BY created_at DESC
`

func (q *Queries) ListTracksSharedByUser(ctx context.Context, sharedBy int64) ([]UserTrackShare, error) {
	rows, err := q.db.QueryContext(ctx, listTracksSharedByUser, sharedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserTrackShare{}
	for rows.Next() {
		var i UserTrackShare
		if err := rows.Scan(
			&i.ID,
			&i.TrackID,
			&i.SharedBy,
			&i.SharedTo,
			&i.CanEdit,
			&i.CanDownload,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksSharedWithUser = `-- name: ListTracksSharedWithUser :many
SELECT DISTINCT t.id, t.user_id, t.project_id, t.title, t.artist, t.album, t.active_version_id, t.created_at, t.updated_at, t.track_order, t."key", t.bpm, t.public_id, t.notes, t.notes_author_name, t.notes_updated_at, t.visibility_status, t.allow_editing, t.allow_downloads, t.password_hash, t.origin_instance_url, t.shared_with_instance_users FROM tracks t
JOIN user_track_shares uts ON t.id = uts.track_id
WHERE uts.shared_to = ?
ORDER BY t.created_at DESC
`

func (q *Queries) ListTracksSharedWithUser(ctx context.Context, sharedTo int64) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksSharedWithUser, sharedTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.ActiveVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackOrder,
			&i.Key,
			&i.Bpm,
			&i.PublicID,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersProjectIsSharedWith = `-- name: ListUsersProjectIsSharedWith :many
SELECT id, project_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at FROM user_project_shares
WHERE project_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListUsersProjectIsSharedWith(ctx context.Context, projectID int64) ([]UserProjectShare, error) {
	rows, err := q.db.QueryContext(ctx, listUsersProjectIsSharedWith, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserProjectShare{}
	for rows.Next() {
		var i UserProjectShare
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SharedBy,
			&i.SharedTo,
			&i.CanEdit,
			&i.CanDownload,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersTrackIsSharedWith = `-- name: ListUsersTrackIsSharedWith :many
SELECT id, track_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at FROM user_track_shares
WHERE track_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListUsersTrackIsSharedWith(ctx context.Context, trackID int64) ([]UserTrackShare, error) {
	rows, err := q.db.QueryContext(ctx, listUsersTrackIsSharedWith, trackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserTrackShare{}
	for rows.Next() {
		var i UserTrackShare
		if err := rows.Scan(
			&i.ID,
			&i.TrackID,
			&i.SharedBy,
			&i.SharedTo,
			&i.CanEdit,
			&i.CanDownload,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebSocketSessionsByResource = `-- name: ListWebSocketSessionsByResource :many
SELECT id, session_id, user_id, user_instance_url, resource_type, resource_id, connected_at, last_heartbeat_at FROM websocket_sessions
WHERE resource_type = ? AND resource_id = ?
ORDER BY connected_at DESC
`

type ListWebSocketSessionsByResourceParams struct {
	ResourceType string `json:"resource_type"`
	ResourceID   string `json:"resource_id"`
}

func (q *Queries) ListWebSocketSessionsByResource(ctx context.Context, arg ListWebSocketSessionsByResourceParams) ([]WebsocketSession, error) {
	rows, err := q.db.QueryContext(ctx, listWebSocketSessionsByResource, arg.ResourceType, arg.ResourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebsocketSession{}
	for rows.Next() {
		var i WebsocketSession
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.UserID,
			&i.UserInstanceUrl,
			&i.ResourceType,
			&i.ResourceID,
			&i.ConnectedAt,
			&i.LastHeartbeatAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFederationTokenLastUsed = `-- name: UpdateFederationTokenLastUsed :exec
UPDATE federation_tokens
SET last_used_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) UpdateFederationTokenLastUsed(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateFederationTokenLastUsed, id)
	return err
}

const updateInstanceConfig = `-- name: UpdateInstanceConfig :one
UPDATE instance_config
SET instance_url = ?,
    instance_name = ?,
    allow_federation = ?,
    allow_public_shares = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1
RETURNING id, instance_url, instance_name, allow_federation, allow_public_shares, created_at, updated_at
`

type UpdateInstanceConfigParams struct {
	InstanceUrl       string `json:"instance_url"`
	InstanceName      string `json:"instance_name"`
	AllowFederation   bool   `json:"allow_federation"`
	AllowPublicShares bool   `json:"allow_public_shares"`
}

func (q *Queries) UpdateInstanceConfig(ctx context.Context, arg UpdateInstanceConfigParams) (InstanceConfig, error) {
	row := q.db.QueryRowContext(ctx, updateInstanceConfig,
		arg.InstanceUrl,
		arg.InstanceName,
		arg.AllowFederation,
		arg.AllowPublicShares,
	)
	var i InstanceConfig
	err := row.Scan(
		&i.ID,
		&i.InstanceUrl,
		&i.InstanceName,
		&i.AllowFederation,
		&i.AllowPublicShares,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectShareToken = `-- name: UpdateProjectShareToken :one
UPDATE project_share_tokens
SET expires_at = ?,
    max_access_count = ?,
    allow_editing = ?,
    allow_downloads = ?,
    password_hash = ?,
    visibility_type = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, token, user_id, project_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at
`

type UpdateProjectShareTokenParams struct {
	ExpiresAt      sql.NullTime   `json:"expires_at"`
	MaxAccessCount sql.NullInt64  `json:"max_access_count"`
	AllowEditing   bool           `json:"allow_editing"`
	AllowDownloads bool           `json:"allow_downloads"`
	PasswordHash   sql.NullString `json:"password_hash"`
	VisibilityType string         `json:"visibility_type"`
	ID             int64          `json:"id"`
	UserID         int64          `json:"user_id"`
}

func (q *Queries) UpdateProjectShareToken(ctx context.Context, arg UpdateProjectShareTokenParams) (ProjectShareToken, error) {
	row := q.db.QueryRowContext(ctx, updateProjectShareToken,
		arg.ExpiresAt,
		arg.MaxAccessCount,
		arg.AllowEditing,
		arg.AllowDownloads,
		arg.PasswordHash,
		arg.VisibilityType,
		arg.ID,
		arg.UserID,
	)
	var i ProjectShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.ProjectID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectVisibility = `-- name: UpdateProjectVisibility :one
UPDATE projects
SET visibility_status = ?,
    allow_editing = ?,
    allow_downloads = ?,
    password_hash = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

type UpdateProjectVisibilityParams struct {
	VisibilityStatus string         `json:"visibility_status"`
	AllowEditing     bool           `json:"allow_editing"`
	AllowDownloads   bool           `json:"allow_downloads"`
	PasswordHash     sql.NullString `json:"password_hash"`
	ID               int64          `json:"id"`
	UserID           int64          `json:"user_id"`
}

func (q *Queries) UpdateProjectVisibility(ctx context.Context, arg UpdateProjectVisibilityParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectVisibility,
		arg.VisibilityStatus,
		arg.AllowEditing,
		arg.AllowDownloads,
		arg.PasswordHash,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const updateProjectVisibilityByPublicID = `-- name: UpdateProjectVisibilityByPublicID :one
UPDATE projects
SET visibility_status = ?,
    allow_editing = ?,
    allow_downloads = ?,
    password_hash = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE public_id = ? AND user_id = ?
RETURNING id, user_id, name, description, quality_override, created_at, updated_at, public_id, cover_art_path, cover_art_mime, cover_art_updated_at, author_override, folder_id, folder_added_at, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users, custom_order, cover_processed
`

type UpdateProjectVisibilityByPublicIDParams struct {
	VisibilityStatus string         `json:"visibility_status"`
	AllowEditing     bool           `json:"allow_editing"`
	AllowDownloads   bool           `json:"allow_downloads"`
	PasswordHash     sql.NullString `json:"password_hash"`
	PublicID         string         `json:"public_id"`
	UserID           int64          `json:"user_id"`
}

func (q *Queries) UpdateProjectVisibilityByPublicID(ctx context.Context, arg UpdateProjectVisibilityByPublicIDParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectVisibilityByPublicID,
		arg.VisibilityStatus,
		arg.AllowEditing,
		arg.AllowDownloads,
		arg.PasswordHash,
		arg.PublicID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.QualityOverride,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicID,
		&i.CoverArtPath,
		&i.CoverArtMime,
		&i.CoverArtUpdatedAt,
		&i.AuthorOverride,
		&i.FolderID,
		&i.FolderAddedAt,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
		&i.CustomOrder,
		&i.CoverProcessed,
	)
	return i, err
}

const updateShareAccessLastAccessed = `-- name: UpdateShareAccessLastAccessed :exec
UPDATE share_access
SET last_accessed_at = CURRENT_TIMESTAMP,
    access_count = access_count + 1
WHERE id = ?
`

func (q *Queries) UpdateShareAccessLastAccessed(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateShareAccessLastAccessed, id)
	return err
}

const updateShareToken = `-- name: UpdateShareToken :one
UPDATE share_tokens
SET expires_at = ?,
    max_access_count = ?,
    allow_editing = ?,
    allow_downloads = ?,
    password_hash = ?,
    visibility_type = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, token, user_id, track_id, version_id, expires_at, max_access_count, current_access_count, allow_editing, allow_downloads, password_hash, visibility_type, created_at, updated_at
`

type UpdateShareTokenParams struct {
	ExpiresAt      sql.NullTime   `json:"expires_at"`
	MaxAccessCount sql.NullInt64  `json:"max_access_count"`
	AllowEditing   bool           `json:"allow_editing"`
	AllowDownloads bool           `json:"allow_downloads"`
	PasswordHash   sql.NullString `json:"password_hash"`
	VisibilityType string         `json:"visibility_type"`
	ID             int64          `json:"id"`
	UserID         int64          `json:"user_id"`
}

func (q *Queries) UpdateShareToken(ctx context.Context, arg UpdateShareTokenParams) (ShareToken, error) {
	row := q.db.QueryRowContext(ctx, updateShareToken,
		arg.ExpiresAt,
		arg.MaxAccessCount,
		arg.AllowEditing,
		arg.AllowDownloads,
		arg.PasswordHash,
		arg.VisibilityType,
		arg.ID,
		arg.UserID,
	)
	var i ShareToken
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.TrackID,
		&i.VersionID,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.CurrentAccessCount,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.VisibilityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTrackVisibility = `-- name: UpdateTrackVisibility :one

UPDATE tracks
SET visibility_status = ?,
    allow_editing = ?,
    allow_downloads = ?,
    password_hash = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users
`

type UpdateTrackVisibilityParams struct {
	VisibilityStatus string         `json:"visibility_status"`
	AllowEditing     bool           `json:"allow_editing"`
	AllowDownloads   bool           `json:"allow_downloads"`
	PasswordHash     sql.NullString `json:"password_hash"`
	ID               int64          `json:"id"`
	UserID           int64          `json:"user_id"`
}

// VISIBILITY STATUS OPERATIONS
func (q *Queries) UpdateTrackVisibility(ctx context.Context, arg UpdateTrackVisibilityParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, updateTrackVisibility,
		arg.VisibilityStatus,
		arg.AllowEditing,
		arg.AllowDownloads,
		arg.PasswordHash,
		arg.ID,
		arg.UserID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const updateTrackVisibilityByPublicID = `-- name: UpdateTrackVisibilityByPublicID :one
UPDATE tracks
SET visibility_status = ?,
    allow_editing = ?,
    allow_downloads = ?,
    password_hash = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE public_id = ? AND user_id = ?
RETURNING id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users
`

type UpdateTrackVisibilityByPublicIDParams struct {
	VisibilityStatus string         `json:"visibility_status"`
	AllowEditing     bool           `json:"allow_editing"`
	AllowDownloads   bool           `json:"allow_downloads"`
	PasswordHash     sql.NullString `json:"password_hash"`
	PublicID         string         `json:"public_id"`
	UserID           int64          `json:"user_id"`
}

func (q *Queries) UpdateTrackVisibilityByPublicID(ctx context.Context, arg UpdateTrackVisibilityByPublicIDParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, updateTrackVisibilityByPublicID,
		arg.VisibilityStatus,
		arg.AllowEditing,
		arg.AllowDownloads,
		arg.PasswordHash,
		arg.PublicID,
		arg.UserID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const updateTrackVisibilityByPublicIDNoUserFilter = `-- name: UpdateTrackVisibilityByPublicIDNoUserFilter :one
UPDATE tracks
SET visibility_status = ?,
    allow_editing = ?,
    allow_downloads = ?,
    password_hash = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE public_id = ?
RETURNING id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users
`

type UpdateTrackVisibilityByPublicIDNoUserFilterParams struct {
	VisibilityStatus string         `json:"visibility_status"`
	AllowEditing     bool           `json:"allow_editing"`
	AllowDownloads   bool           `json:"allow_downloads"`
	PasswordHash     sql.NullString `json:"password_hash"`
	PublicID         string         `json:"public_id"`
}

func (q *Queries) UpdateTrackVisibilityByPublicIDNoUserFilter(ctx context.Context, arg UpdateTrackVisibilityByPublicIDNoUserFilterParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, updateTrackVisibilityByPublicIDNoUserFilter,
		arg.VisibilityStatus,
		arg.AllowEditing,
		arg.AllowDownloads,
		arg.PasswordHash,
		arg.PublicID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const updateUserProjectShare = `-- name: UpdateUserProjectShare :one
UPDATE user_project_shares
SET can_edit = ?, can_download = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND shared_by = ?
RETURNING id, project_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at
`

type UpdateUserProjectShareParams struct {
	CanEdit     bool  `json:"can_edit"`
	CanDownload bool  `json:"can_download"`
	ID          int64 `json:"id"`
	SharedBy    int64 `json:"shared_by"`
}

func (q *Queries) UpdateUserProjectShare(ctx context.Context, arg UpdateUserProjectShareParams) (UserProjectShare, error) {
	row := q.db.QueryRowContext(ctx, updateUserProjectShare,
		arg.CanEdit,
		arg.CanDownload,
		arg.ID,
		arg.SharedBy,
	)
	var i UserProjectShare
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SharedBy,
		&i.SharedTo,
		&i.CanEdit,
		&i.CanDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserTrackShare = `-- name: UpdateUserTrackShare :one
UPDATE user_track_shares
SET can_edit = ?, can_download = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND shared_by = ?
RETURNING id, track_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at
`

type UpdateUserTrackShareParams struct {
	CanEdit     bool  `json:"can_edit"`
	CanDownload bool  `json:"can_download"`
	ID          int64 `json:"id"`
	SharedBy    int64 `json:"shared_by"`
}

func (q *Queries) UpdateUserTrackShare(ctx context.Context, arg UpdateUserTrackShareParams) (UserTrackShare, error) {
	row := q.db.QueryRowContext(ctx, updateUserTrackShare,
		arg.CanEdit,
		arg.CanDownload,
		arg.ID,
		arg.SharedBy,
	)
	var i UserTrackShare
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.SharedBy,
		&i.SharedTo,
		&i.CanEdit,
		&i.CanDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserTrackShareByID = `-- name: UpdateUserTrackShareByID :one
UPDATE user_track_shares
SET can_edit = ?, can_download = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, track_id, shared_by, shared_to, can_edit, can_download, created_at, updated_at
`

type UpdateUserTrackShareByIDParams struct {
	CanEdit     bool  `json:"can_edit"`
	CanDownload bool  `json:"can_download"`
	ID          int64 `json:"id"`
}

func (q *Queries) UpdateUserTrackShareByID(ctx context.Context, arg UpdateUserTrackShareByIDParams) (UserTrackShare, error) {
	row := q.db.QueryRowContext(ctx, updateUserTrackShareByID, arg.CanEdit, arg.CanDownload, arg.ID)
	var i UserTrackShare
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.SharedBy,
		&i.SharedTo,
		&i.CanEdit,
		&i.CanDownload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWebSocketHeartbeat = `-- name: UpdateWebSocketHeartbeat :exec
UPDATE websocket_sessions
SET last_heartbeat_at = CURRENT_TIMESTAMP
WHERE session_id = ?
`

func (q *Queries) UpdateWebSocketHeartbeat(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, updateWebSocketHeartbeat, sessionID)
	return err
}
