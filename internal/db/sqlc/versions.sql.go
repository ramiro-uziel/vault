// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: versions.sql

package db

import (
	"context"
	"database/sql"
)

const countTrackVersions = `-- name: CountTrackVersions :one
SELECT COUNT(*) FROM track_versions
WHERE track_id = ?
`

func (q *Queries) CountTrackVersions(ctx context.Context, trackID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTrackVersions, trackID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTrackVersion = `-- name: CreateTrackVersion :one
INSERT INTO track_versions (track_id, version_name, notes, duration_seconds, version_order)
VALUES (?, ?, ?, ?, ?)
RETURNING id, track_id, version_name, notes, duration_seconds, version_order, created_at, updated_at
`

type CreateTrackVersionParams struct {
	TrackID         int64           `json:"track_id"`
	VersionName     string          `json:"version_name"`
	Notes           sql.NullString  `json:"notes"`
	DurationSeconds sql.NullFloat64 `json:"duration_seconds"`
	VersionOrder    int64           `json:"version_order"`
}

func (q *Queries) CreateTrackVersion(ctx context.Context, arg CreateTrackVersionParams) (TrackVersion, error) {
	row := q.db.QueryRowContext(ctx, createTrackVersion,
		arg.TrackID,
		arg.VersionName,
		arg.Notes,
		arg.DurationSeconds,
		arg.VersionOrder,
	)
	var i TrackVersion
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.VersionName,
		&i.Notes,
		&i.DurationSeconds,
		&i.VersionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTrackVersion = `-- name: DeleteTrackVersion :exec
DELETE FROM track_versions
WHERE id = ?
`

func (q *Queries) DeleteTrackVersion(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTrackVersion, id)
	return err
}

const getMaxVersionOrder = `-- name: GetMaxVersionOrder :one
SELECT COALESCE(MAX(version_order), -1) as max_order
FROM track_versions
WHERE track_id = ?
`

func (q *Queries) GetMaxVersionOrder(ctx context.Context, trackID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxVersionOrder, trackID)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const getTrackVersion = `-- name: GetTrackVersion :one
SELECT id, track_id, version_name, notes, duration_seconds, version_order, created_at, updated_at FROM track_versions
WHERE id = ?
`

func (q *Queries) GetTrackVersion(ctx context.Context, id int64) (TrackVersion, error) {
	row := q.db.QueryRowContext(ctx, getTrackVersion, id)
	var i TrackVersion
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.VersionName,
		&i.Notes,
		&i.DurationSeconds,
		&i.VersionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTrackVersionWithOwnership = `-- name: GetTrackVersionWithOwnership :one
SELECT tv.id, tv.track_id, tv.version_name, tv.notes, tv.duration_seconds, tv.version_order, tv.created_at, tv.updated_at, t.user_id
FROM track_versions tv
JOIN tracks t ON tv.track_id = t.id
WHERE tv.id = ?
`

type GetTrackVersionWithOwnershipRow struct {
	ID              int64           `json:"id"`
	TrackID         int64           `json:"track_id"`
	VersionName     string          `json:"version_name"`
	Notes           sql.NullString  `json:"notes"`
	DurationSeconds sql.NullFloat64 `json:"duration_seconds"`
	VersionOrder    int64           `json:"version_order"`
	CreatedAt       sql.NullTime    `json:"created_at"`
	UpdatedAt       sql.NullTime    `json:"updated_at"`
	UserID          int64           `json:"user_id"`
}

func (q *Queries) GetTrackVersionWithOwnership(ctx context.Context, id int64) (GetTrackVersionWithOwnershipRow, error) {
	row := q.db.QueryRowContext(ctx, getTrackVersionWithOwnership, id)
	var i GetTrackVersionWithOwnershipRow
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.VersionName,
		&i.Notes,
		&i.DurationSeconds,
		&i.VersionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const listTrackVersions = `-- name: ListTrackVersions :many
SELECT id, track_id, version_name, notes, duration_seconds, version_order, created_at, updated_at FROM track_versions
WHERE track_id = ?
ORDER BY version_order ASC, created_at ASC
`

func (q *Queries) ListTrackVersions(ctx context.Context, trackID int64) ([]TrackVersion, error) {
	rows, err := q.db.QueryContext(ctx, listTrackVersions, trackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TrackVersion{}
	for rows.Next() {
		var i TrackVersion
		if err := rows.Scan(
			&i.ID,
			&i.TrackID,
			&i.VersionName,
			&i.Notes,
			&i.DurationSeconds,
			&i.VersionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrackVersionsWithMetadata = `-- name: ListTrackVersionsWithMetadata :many
SELECT 
    tv.id, tv.track_id, tv.version_name, tv.notes, tv.duration_seconds, tv.version_order, tv.created_at, tv.updated_at,
    tf_source.file_size as source_file_size,
    tf_source.format as source_format,
    tf_source.bitrate as source_bitrate,
    tf_lossy.transcoding_status as lossy_transcoding_status
FROM track_versions tv
LEFT JOIN track_files tf_source ON tv.id = tf_source.version_id AND tf_source.quality = 'source'
LEFT JOIN track_files tf_lossy ON tv.id = tf_lossy.version_id AND tf_lossy.quality = 'lossy'
WHERE tv.track_id = ?
ORDER BY tv.version_order ASC, tv.created_at ASC
`

type ListTrackVersionsWithMetadataRow struct {
	ID                     int64           `json:"id"`
	TrackID                int64           `json:"track_id"`
	VersionName            string          `json:"version_name"`
	Notes                  sql.NullString  `json:"notes"`
	DurationSeconds        sql.NullFloat64 `json:"duration_seconds"`
	VersionOrder           int64           `json:"version_order"`
	CreatedAt              sql.NullTime    `json:"created_at"`
	UpdatedAt              sql.NullTime    `json:"updated_at"`
	SourceFileSize         sql.NullInt64   `json:"source_file_size"`
	SourceFormat           sql.NullString  `json:"source_format"`
	SourceBitrate          sql.NullInt64   `json:"source_bitrate"`
	LossyTranscodingStatus sql.NullString  `json:"lossy_transcoding_status"`
}

func (q *Queries) ListTrackVersionsWithMetadata(ctx context.Context, trackID int64) ([]ListTrackVersionsWithMetadataRow, error) {
	rows, err := q.db.QueryContext(ctx, listTrackVersionsWithMetadata, trackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTrackVersionsWithMetadataRow{}
	for rows.Next() {
		var i ListTrackVersionsWithMetadataRow
		if err := rows.Scan(
			&i.ID,
			&i.TrackID,
			&i.VersionName,
			&i.Notes,
			&i.DurationSeconds,
			&i.VersionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceFileSize,
			&i.SourceFormat,
			&i.SourceBitrate,
			&i.LossyTranscodingStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTrackVersion = `-- name: UpdateTrackVersion :one
UPDATE track_versions
SET version_name = COALESCE(?, version_name),
    notes = COALESCE(?, notes),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, track_id, version_name, notes, duration_seconds, version_order, created_at, updated_at
`

type UpdateTrackVersionParams struct {
	VersionName string         `json:"version_name"`
	Notes       sql.NullString `json:"notes"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateTrackVersion(ctx context.Context, arg UpdateTrackVersionParams) (TrackVersion, error) {
	row := q.db.QueryRowContext(ctx, updateTrackVersion, arg.VersionName, arg.Notes, arg.ID)
	var i TrackVersion
	err := row.Scan(
		&i.ID,
		&i.TrackID,
		&i.VersionName,
		&i.Notes,
		&i.DurationSeconds,
		&i.VersionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTrackVersionDuration = `-- name: UpdateTrackVersionDuration :exec
UPDATE track_versions
SET duration_seconds = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateTrackVersionDurationParams struct {
	DurationSeconds sql.NullFloat64 `json:"duration_seconds"`
	ID              int64           `json:"id"`
}

func (q *Queries) UpdateTrackVersionDuration(ctx context.Context, arg UpdateTrackVersionDurationParams) error {
	_, err := q.db.ExecContext(ctx, updateTrackVersionDuration, arg.DurationSeconds, arg.ID)
	return err
}
