// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tracks.sql

package db

import (
	"context"
	"database/sql"
)

const clearAllTracksAnalysis = `-- name: ClearAllTracksAnalysis :exec
UPDATE tracks
SET bpm = NULL, key = NULL, updated_at = CURRENT_TIMESTAMP
`

func (q *Queries) ClearAllTracksAnalysis(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearAllTracksAnalysis)
	return err
}

const clearTrackAnalysis = `-- name: ClearTrackAnalysis :exec
UPDATE tracks
SET bpm = NULL, key = NULL, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) ClearTrackAnalysis(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, clearTrackAnalysis, id)
	return err
}

const createTrack = `-- name: CreateTrack :one
INSERT INTO tracks (user_id, project_id, title, artist, album, public_id)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users
`

type CreateTrackParams struct {
	UserID    int64          `json:"user_id"`
	ProjectID int64          `json:"project_id"`
	Title     string         `json:"title"`
	Artist    sql.NullString `json:"artist"`
	Album     sql.NullString `json:"album"`
	PublicID  string         `json:"public_id"`
}

func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, createTrack,
		arg.UserID,
		arg.ProjectID,
		arg.Title,
		arg.Artist,
		arg.Album,
		arg.PublicID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const deleteTrack = `-- name: DeleteTrack :exec
DELETE FROM tracks
WHERE id = ? AND user_id = ?
`

type DeleteTrackParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteTrack(ctx context.Context, arg DeleteTrackParams) error {
	_, err := q.db.ExecContext(ctx, deleteTrack, arg.ID, arg.UserID)
	return err
}

const getMaxTrackOrderByProject = `-- name: GetMaxTrackOrderByProject :one
SELECT COALESCE(MAX(track_order), -1) as max_order
FROM tracks
WHERE project_id = ?
`

func (q *Queries) GetMaxTrackOrderByProject(ctx context.Context, projectID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxTrackOrderByProject, projectID)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const getTrack = `-- name: GetTrack :one
SELECT id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users FROM tracks
WHERE id = ? AND user_id = ?
`

type GetTrackParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetTrack(ctx context.Context, arg GetTrackParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, getTrack, arg.ID, arg.UserID)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const getTrackByID = `-- name: GetTrackByID :one
SELECT id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users FROM tracks
WHERE id = ?
`

func (q *Queries) GetTrackByID(ctx context.Context, id int64) (Track, error) {
	row := q.db.QueryRowContext(ctx, getTrackByID, id)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const getTrackByPublicID = `-- name: GetTrackByPublicID :one
SELECT id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users FROM tracks
WHERE public_id = ? AND user_id = ?
`

type GetTrackByPublicIDParams struct {
	PublicID string `json:"public_id"`
	UserID   int64  `json:"user_id"`
}

func (q *Queries) GetTrackByPublicID(ctx context.Context, arg GetTrackByPublicIDParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, getTrackByPublicID, arg.PublicID, arg.UserID)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const getTrackByPublicIDNoFilter = `-- name: GetTrackByPublicIDNoFilter :one
SELECT id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users FROM tracks
WHERE public_id = ?
`

func (q *Queries) GetTrackByPublicIDNoFilter(ctx context.Context, publicID string) (Track, error) {
	row := q.db.QueryRowContext(ctx, getTrackByPublicIDNoFilter, publicID)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const getTrackWithDetails = `-- name: GetTrackWithDetails :one
SELECT
    t.id,
    t.user_id,
    t.project_id,
    t.public_id,
    t.title,
    t.artist,
    t.album,
    t.key,
    t.bpm,
    t.active_version_id,
    t.track_order,
    t.visibility_status,
    t.created_at,
    t.updated_at,
    tv.version_name as active_version_name,
    tv.duration_seconds as active_version_duration_seconds,
    p.name as project_name,
    tf.waveform as waveform,
    tf.transcoding_status as lossy_transcoding_status
FROM tracks t
LEFT JOIN track_versions tv ON t.active_version_id = tv.id
LEFT JOIN track_files tf ON tv.id = tf.version_id AND tf.quality = 'lossy'
JOIN projects p ON t.project_id = p.id
WHERE t.id = ? AND t.user_id = ?
`

type GetTrackWithDetailsParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

type GetTrackWithDetailsRow struct {
	ID                           int64           `json:"id"`
	UserID                       int64           `json:"user_id"`
	ProjectID                    int64           `json:"project_id"`
	PublicID                     string          `json:"public_id"`
	Title                        string          `json:"title"`
	Artist                       sql.NullString  `json:"artist"`
	Album                        sql.NullString  `json:"album"`
	Key                          sql.NullString  `json:"key"`
	Bpm                          sql.NullInt64   `json:"bpm"`
	ActiveVersionID              sql.NullInt64   `json:"active_version_id"`
	TrackOrder                   int64           `json:"track_order"`
	VisibilityStatus             string          `json:"visibility_status"`
	CreatedAt                    sql.NullTime    `json:"created_at"`
	UpdatedAt                    sql.NullTime    `json:"updated_at"`
	ActiveVersionName            string          `json:"active_version_name"`
	ActiveVersionDurationSeconds sql.NullFloat64 `json:"active_version_duration_seconds"`
	ProjectName                  string          `json:"project_name"`
	Waveform                     sql.NullString  `json:"waveform"`
	LossyTranscodingStatus       sql.NullString  `json:"lossy_transcoding_status"`
}

func (q *Queries) GetTrackWithDetails(ctx context.Context, arg GetTrackWithDetailsParams) (GetTrackWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getTrackWithDetails, arg.ID, arg.UserID)
	var i GetTrackWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.PublicID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.Key,
		&i.Bpm,
		&i.ActiveVersionID,
		&i.TrackOrder,
		&i.VisibilityStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ActiveVersionName,
		&i.ActiveVersionDurationSeconds,
		&i.ProjectName,
		&i.Waveform,
		&i.LossyTranscodingStatus,
	)
	return i, err
}

const listPlainTracksByProject = `-- name: ListPlainTracksByProject :many
SELECT id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users FROM tracks
WHERE user_id = ? AND project_id = ?
ORDER BY track_order ASC
`

type ListPlainTracksByProjectParams struct {
	UserID    int64 `json:"user_id"`
	ProjectID int64 `json:"project_id"`
}

func (q *Queries) ListPlainTracksByProject(ctx context.Context, arg ListPlainTracksByProjectParams) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listPlainTracksByProject, arg.UserID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.ActiveVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackOrder,
			&i.Key,
			&i.Bpm,
			&i.PublicID,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByProject = `-- name: ListTracksByProject :many
SELECT
    t.id, t.user_id, t.project_id, t.title, t.artist, t.album, t.active_version_id, t.created_at, t.updated_at, t.track_order, t."key", t.bpm, t.public_id, t.notes, t.notes_author_name, t.notes_updated_at, t.visibility_status, t.allow_editing, t.allow_downloads, t.password_hash, t.origin_instance_url, t.shared_with_instance_users,
    COALESCE(tv.version_name, '') as active_version_name,
    tv.duration_seconds as active_version_duration_seconds,
    p.name as project_name,
    tf.waveform as waveform,
    tf.transcoding_status as lossy_transcoding_status,
    CASE WHEN EXISTS (
        SELECT 1 FROM user_track_shares uts
        WHERE uts.track_id = t.id
    ) OR EXISTS (
        SELECT 1 FROM user_project_shares ups
        WHERE ups.project_id = t.project_id
    ) THEN 1 ELSE 0 END as is_shared
FROM tracks t
LEFT JOIN track_versions tv ON t.active_version_id = tv.id
LEFT JOIN track_files tf ON tv.id = tf.version_id AND tf.quality = 'lossy'
JOIN projects p ON t.project_id = p.id
WHERE t.user_id = ? AND t.project_id = ?
ORDER BY t.track_order ASC
`

type ListTracksByProjectParams struct {
	UserID    int64 `json:"user_id"`
	ProjectID int64 `json:"project_id"`
}

type ListTracksByProjectRow struct {
	ID                           int64           `json:"id"`
	UserID                       int64           `json:"user_id"`
	ProjectID                    int64           `json:"project_id"`
	Title                        string          `json:"title"`
	Artist                       sql.NullString  `json:"artist"`
	Album                        sql.NullString  `json:"album"`
	ActiveVersionID              sql.NullInt64   `json:"active_version_id"`
	CreatedAt                    sql.NullTime    `json:"created_at"`
	UpdatedAt                    sql.NullTime    `json:"updated_at"`
	TrackOrder                   int64           `json:"track_order"`
	Key                          sql.NullString  `json:"key"`
	Bpm                          sql.NullInt64   `json:"bpm"`
	PublicID                     string          `json:"public_id"`
	Notes                        sql.NullString  `json:"notes"`
	NotesAuthorName              sql.NullString  `json:"notes_author_name"`
	NotesUpdatedAt               sql.NullTime    `json:"notes_updated_at"`
	VisibilityStatus             string          `json:"visibility_status"`
	AllowEditing                 bool            `json:"allow_editing"`
	AllowDownloads               bool            `json:"allow_downloads"`
	PasswordHash                 sql.NullString  `json:"password_hash"`
	OriginInstanceUrl            sql.NullString  `json:"origin_instance_url"`
	SharedWithInstanceUsers      sql.NullBool    `json:"shared_with_instance_users"`
	ActiveVersionName            string          `json:"active_version_name"`
	ActiveVersionDurationSeconds sql.NullFloat64 `json:"active_version_duration_seconds"`
	ProjectName                  string          `json:"project_name"`
	Waveform                     sql.NullString  `json:"waveform"`
	LossyTranscodingStatus       sql.NullString  `json:"lossy_transcoding_status"`
	IsShared                     int64           `json:"is_shared"`
}

func (q *Queries) ListTracksByProject(ctx context.Context, arg ListTracksByProjectParams) ([]ListTracksByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByProject, arg.UserID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTracksByProjectRow{}
	for rows.Next() {
		var i ListTracksByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.ActiveVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackOrder,
			&i.Key,
			&i.Bpm,
			&i.PublicID,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
			&i.ActiveVersionName,
			&i.ActiveVersionDurationSeconds,
			&i.ProjectName,
			&i.Waveform,
			&i.LossyTranscodingStatus,
			&i.IsShared,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByProjectID = `-- name: ListTracksByProjectID :many
SELECT id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users FROM tracks
WHERE project_id = ?
ORDER BY track_order ASC
`

func (q *Queries) ListTracksByProjectID(ctx context.Context, projectID int64) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.ActiveVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackOrder,
			&i.Key,
			&i.Bpm,
			&i.PublicID,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByUser = `-- name: ListTracksByUser :many
SELECT
    t.id, t.user_id, t.project_id, t.title, t.artist, t.album, t.active_version_id, t.created_at, t.updated_at, t.track_order, t."key", t.bpm, t.public_id, t.notes, t.notes_author_name, t.notes_updated_at, t.visibility_status, t.allow_editing, t.allow_downloads, t.password_hash, t.origin_instance_url, t.shared_with_instance_users,
    COALESCE(tv.version_name, '') as active_version_name,
    tv.duration_seconds as active_version_duration_seconds,
    p.name as project_name,
    tf.waveform as waveform,
    tf.transcoding_status as lossy_transcoding_status
FROM tracks t
LEFT JOIN track_versions tv ON t.active_version_id = tv.id
LEFT JOIN track_files tf ON tv.id = tf.version_id AND tf.quality = 'lossy'
JOIN projects p ON t.project_id = p.id
WHERE p.user_id = ?
ORDER BY t.created_at DESC
`

type ListTracksByUserRow struct {
	ID                           int64           `json:"id"`
	UserID                       int64           `json:"user_id"`
	ProjectID                    int64           `json:"project_id"`
	Title                        string          `json:"title"`
	Artist                       sql.NullString  `json:"artist"`
	Album                        sql.NullString  `json:"album"`
	ActiveVersionID              sql.NullInt64   `json:"active_version_id"`
	CreatedAt                    sql.NullTime    `json:"created_at"`
	UpdatedAt                    sql.NullTime    `json:"updated_at"`
	TrackOrder                   int64           `json:"track_order"`
	Key                          sql.NullString  `json:"key"`
	Bpm                          sql.NullInt64   `json:"bpm"`
	PublicID                     string          `json:"public_id"`
	Notes                        sql.NullString  `json:"notes"`
	NotesAuthorName              sql.NullString  `json:"notes_author_name"`
	NotesUpdatedAt               sql.NullTime    `json:"notes_updated_at"`
	VisibilityStatus             string          `json:"visibility_status"`
	AllowEditing                 bool            `json:"allow_editing"`
	AllowDownloads               bool            `json:"allow_downloads"`
	PasswordHash                 sql.NullString  `json:"password_hash"`
	OriginInstanceUrl            sql.NullString  `json:"origin_instance_url"`
	SharedWithInstanceUsers      sql.NullBool    `json:"shared_with_instance_users"`
	ActiveVersionName            string          `json:"active_version_name"`
	ActiveVersionDurationSeconds sql.NullFloat64 `json:"active_version_duration_seconds"`
	ProjectName                  string          `json:"project_name"`
	Waveform                     sql.NullString  `json:"waveform"`
	LossyTranscodingStatus       sql.NullString  `json:"lossy_transcoding_status"`
}

func (q *Queries) ListTracksByUser(ctx context.Context, userID int64) ([]ListTracksByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTracksByUserRow{}
	for rows.Next() {
		var i ListTracksByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.ActiveVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackOrder,
			&i.Key,
			&i.Bpm,
			&i.PublicID,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
			&i.ActiveVersionName,
			&i.ActiveVersionDurationSeconds,
			&i.ProjectName,
			&i.Waveform,
			&i.LossyTranscodingStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksWithDetailsByProjectID = `-- name: ListTracksWithDetailsByProjectID :many
SELECT
    t.id, t.user_id, t.project_id, t.title, t.artist, t.album, t.active_version_id, t.created_at, t.updated_at, t.track_order, t."key", t.bpm, t.public_id, t.notes, t.notes_author_name, t.notes_updated_at, t.visibility_status, t.allow_editing, t.allow_downloads, t.password_hash, t.origin_instance_url, t.shared_with_instance_users,
    COALESCE(tv.version_name, '') as active_version_name,
    tv.duration_seconds as active_version_duration_seconds,
    p.name as project_name,
    tf.waveform as waveform,
    tf.transcoding_status as lossy_transcoding_status,
    CASE WHEN EXISTS (
        SELECT 1 FROM user_track_shares uts
        WHERE uts.track_id = t.id
    ) OR EXISTS (
        SELECT 1 FROM user_project_shares ups
        WHERE ups.project_id = t.project_id
    ) THEN 1 ELSE 0 END as is_shared
FROM tracks t
LEFT JOIN track_versions tv ON t.active_version_id = tv.id
LEFT JOIN track_files tf ON tv.id = tf.version_id AND tf.quality = 'lossy'
JOIN projects p ON t.project_id = p.id
WHERE t.project_id = ?
ORDER BY t.track_order ASC
`

type ListTracksWithDetailsByProjectIDRow struct {
	ID                           int64           `json:"id"`
	UserID                       int64           `json:"user_id"`
	ProjectID                    int64           `json:"project_id"`
	Title                        string          `json:"title"`
	Artist                       sql.NullString  `json:"artist"`
	Album                        sql.NullString  `json:"album"`
	ActiveVersionID              sql.NullInt64   `json:"active_version_id"`
	CreatedAt                    sql.NullTime    `json:"created_at"`
	UpdatedAt                    sql.NullTime    `json:"updated_at"`
	TrackOrder                   int64           `json:"track_order"`
	Key                          sql.NullString  `json:"key"`
	Bpm                          sql.NullInt64   `json:"bpm"`
	PublicID                     string          `json:"public_id"`
	Notes                        sql.NullString  `json:"notes"`
	NotesAuthorName              sql.NullString  `json:"notes_author_name"`
	NotesUpdatedAt               sql.NullTime    `json:"notes_updated_at"`
	VisibilityStatus             string          `json:"visibility_status"`
	AllowEditing                 bool            `json:"allow_editing"`
	AllowDownloads               bool            `json:"allow_downloads"`
	PasswordHash                 sql.NullString  `json:"password_hash"`
	OriginInstanceUrl            sql.NullString  `json:"origin_instance_url"`
	SharedWithInstanceUsers      sql.NullBool    `json:"shared_with_instance_users"`
	ActiveVersionName            string          `json:"active_version_name"`
	ActiveVersionDurationSeconds sql.NullFloat64 `json:"active_version_duration_seconds"`
	ProjectName                  string          `json:"project_name"`
	Waveform                     sql.NullString  `json:"waveform"`
	LossyTranscodingStatus       sql.NullString  `json:"lossy_transcoding_status"`
	IsShared                     int64           `json:"is_shared"`
}

func (q *Queries) ListTracksWithDetailsByProjectID(ctx context.Context, projectID int64) ([]ListTracksWithDetailsByProjectIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listTracksWithDetailsByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTracksWithDetailsByProjectIDRow{}
	for rows.Next() {
		var i ListTracksWithDetailsByProjectIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.ActiveVersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TrackOrder,
			&i.Key,
			&i.Bpm,
			&i.PublicID,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.VisibilityStatus,
			&i.AllowEditing,
			&i.AllowDownloads,
			&i.PasswordHash,
			&i.OriginInstanceUrl,
			&i.SharedWithInstanceUsers,
			&i.ActiveVersionName,
			&i.ActiveVersionDurationSeconds,
			&i.ProjectName,
			&i.Waveform,
			&i.LossyTranscodingStatus,
			&i.IsShared,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksWithoutAnalysis = `-- name: ListTracksWithoutAnalysis :many
SELECT t.id, t.title, t.artist, t.bpm, t.key, t.active_version_id
FROM tracks t
WHERE (t.bpm IS NULL OR t.key IS NULL) AND t.active_version_id IS NOT NULL
`

type ListTracksWithoutAnalysisRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Artist          sql.NullString `json:"artist"`
	Bpm             sql.NullInt64  `json:"bpm"`
	Key             sql.NullString `json:"key"`
	ActiveVersionID sql.NullInt64  `json:"active_version_id"`
}

func (q *Queries) ListTracksWithoutAnalysis(ctx context.Context) ([]ListTracksWithoutAnalysisRow, error) {
	rows, err := q.db.QueryContext(ctx, listTracksWithoutAnalysis)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTracksWithoutAnalysisRow{}
	for rows.Next() {
		var i ListTracksWithoutAnalysisRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.Bpm,
			&i.Key,
			&i.ActiveVersionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksWithoutBPM = `-- name: ListTracksWithoutBPM :many
SELECT t.id, t.title, t.artist, t.active_version_id
FROM tracks t
WHERE t.bpm IS NULL AND t.active_version_id IS NOT NULL
`

type ListTracksWithoutBPMRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Artist          sql.NullString `json:"artist"`
	ActiveVersionID sql.NullInt64  `json:"active_version_id"`
}

func (q *Queries) ListTracksWithoutBPM(ctx context.Context) ([]ListTracksWithoutBPMRow, error) {
	rows, err := q.db.QueryContext(ctx, listTracksWithoutBPM)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTracksWithoutBPMRow{}
	for rows.Next() {
		var i ListTracksWithoutBPMRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Artist,
			&i.ActiveVersionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTracksAccessibleByUser = `-- name: SearchTracksAccessibleByUser :many
SELECT DISTINCT
    t.id,
    t.user_id,
    t.project_id,
    t.public_id,
    t.title,
    t.artist,
    t.album,
    t.key,
    t.bpm,
    t.notes,
    t.notes_author_name,
    t.notes_updated_at,
    t.active_version_id,
    t.track_order,
    t.visibility_status,
    t.created_at,
    t.updated_at,
    COALESCE(tv.version_name, '') as active_version_name,
    tv.duration_seconds as active_version_duration_seconds,
    p.name as project_name,
    tf.waveform as waveform,
    tf.transcoding_status as lossy_transcoding_status,
    CASE WHEN EXISTS (
        SELECT 1 FROM user_project_shares ups
        WHERE ups.project_id = t.project_id
        AND ups.shared_to = ?1
    ) THEN 1 ELSE 0 END as is_shared
FROM tracks t
LEFT JOIN track_versions tv ON t.active_version_id = tv.id
LEFT JOIN track_files tf ON tv.id = tf.version_id AND tf.quality = 'lossy'
JOIN projects p ON t.project_id = p.id
WHERE (
    -- User's own projects
    p.user_id = ?1
    OR
    -- Projects shared with user
    EXISTS (
        SELECT 1 FROM user_project_shares ups
        WHERE ups.project_id = p.id
        AND ups.shared_to = ?1
    )
)
AND (
    -- Search filter (case-insensitive)
    ?2 = '' OR
    LOWER(t.title) LIKE '%' || LOWER(?2) || '%' OR
    LOWER(COALESCE(t.artist, '')) LIKE '%' || LOWER(?2) || '%' OR
    LOWER(p.name) LIKE '%' || LOWER(?2) || '%'
)
ORDER BY t.updated_at DESC
LIMIT ?3
`

type SearchTracksAccessibleByUserParams struct {
	UserID      int64       `json:"user_id"`
	SearchQuery interface{} `json:"search_query"`
	LimitCount  int64       `json:"limit_count"`
}

type SearchTracksAccessibleByUserRow struct {
	ID                           int64           `json:"id"`
	UserID                       int64           `json:"user_id"`
	ProjectID                    int64           `json:"project_id"`
	PublicID                     string          `json:"public_id"`
	Title                        string          `json:"title"`
	Artist                       sql.NullString  `json:"artist"`
	Album                        sql.NullString  `json:"album"`
	Key                          sql.NullString  `json:"key"`
	Bpm                          sql.NullInt64   `json:"bpm"`
	Notes                        sql.NullString  `json:"notes"`
	NotesAuthorName              sql.NullString  `json:"notes_author_name"`
	NotesUpdatedAt               sql.NullTime    `json:"notes_updated_at"`
	ActiveVersionID              sql.NullInt64   `json:"active_version_id"`
	TrackOrder                   int64           `json:"track_order"`
	VisibilityStatus             string          `json:"visibility_status"`
	CreatedAt                    sql.NullTime    `json:"created_at"`
	UpdatedAt                    sql.NullTime    `json:"updated_at"`
	ActiveVersionName            string          `json:"active_version_name"`
	ActiveVersionDurationSeconds sql.NullFloat64 `json:"active_version_duration_seconds"`
	ProjectName                  string          `json:"project_name"`
	Waveform                     sql.NullString  `json:"waveform"`
	LossyTranscodingStatus       sql.NullString  `json:"lossy_transcoding_status"`
	IsShared                     int64           `json:"is_shared"`
}

func (q *Queries) SearchTracksAccessibleByUser(ctx context.Context, arg SearchTracksAccessibleByUserParams) ([]SearchTracksAccessibleByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, searchTracksAccessibleByUser, arg.UserID, arg.SearchQuery, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchTracksAccessibleByUserRow{}
	for rows.Next() {
		var i SearchTracksAccessibleByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.PublicID,
			&i.Title,
			&i.Artist,
			&i.Album,
			&i.Key,
			&i.Bpm,
			&i.Notes,
			&i.NotesAuthorName,
			&i.NotesUpdatedAt,
			&i.ActiveVersionID,
			&i.TrackOrder,
			&i.VisibilityStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ActiveVersionName,
			&i.ActiveVersionDurationSeconds,
			&i.ProjectName,
			&i.Waveform,
			&i.LossyTranscodingStatus,
			&i.IsShared,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setActiveVersion = `-- name: SetActiveVersion :exec
UPDATE tracks
SET active_version_id = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type SetActiveVersionParams struct {
	ActiveVersionID sql.NullInt64 `json:"active_version_id"`
	ID              int64         `json:"id"`
}

func (q *Queries) SetActiveVersion(ctx context.Context, arg SetActiveVersionParams) error {
	_, err := q.db.ExecContext(ctx, setActiveVersion, arg.ActiveVersionID, arg.ID)
	return err
}

const updateTrack = `-- name: UpdateTrack :one
UPDATE tracks
SET title = COALESCE(?, title),
    artist = COALESCE(?, artist),
    album = COALESCE(?, album),
    project_id = COALESCE(?, project_id),
    key = COALESCE(?, key),
    bpm = COALESCE(?, bpm),
    notes = COALESCE(?, notes),
    notes_author_name = COALESCE(?, notes_author_name),
    notes_updated_at = CASE WHEN ? IS NOT NULL THEN CURRENT_TIMESTAMP ELSE notes_updated_at END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users
`

type UpdateTrackParams struct {
	Title           string         `json:"title"`
	Artist          sql.NullString `json:"artist"`
	Album           sql.NullString `json:"album"`
	ProjectID       int64          `json:"project_id"`
	Key             sql.NullString `json:"key"`
	Bpm             sql.NullInt64  `json:"bpm"`
	Notes           sql.NullString `json:"notes"`
	NotesAuthorName sql.NullString `json:"notes_author_name"`
	Column9         interface{}    `json:"column_9"`
	ID              int64          `json:"id"`
	UserID          int64          `json:"user_id"`
}

func (q *Queries) UpdateTrack(ctx context.Context, arg UpdateTrackParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, updateTrack,
		arg.Title,
		arg.Artist,
		arg.Album,
		arg.ProjectID,
		arg.Key,
		arg.Bpm,
		arg.Notes,
		arg.NotesAuthorName,
		arg.Column9,
		arg.ID,
		arg.UserID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const updateTrackAnalysis = `-- name: UpdateTrackAnalysis :exec
UPDATE tracks
SET bpm = ?, key = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateTrackAnalysisParams struct {
	Bpm sql.NullInt64  `json:"bpm"`
	Key sql.NullString `json:"key"`
	ID  int64          `json:"id"`
}

func (q *Queries) UpdateTrackAnalysis(ctx context.Context, arg UpdateTrackAnalysisParams) error {
	_, err := q.db.ExecContext(ctx, updateTrackAnalysis, arg.Bpm, arg.Key, arg.ID)
	return err
}

const updateTrackBPM = `-- name: UpdateTrackBPM :exec
UPDATE tracks
SET bpm = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateTrackBPMParams struct {
	Bpm sql.NullInt64 `json:"bpm"`
	ID  int64         `json:"id"`
}

func (q *Queries) UpdateTrackBPM(ctx context.Context, arg UpdateTrackBPMParams) error {
	_, err := q.db.ExecContext(ctx, updateTrackBPM, arg.Bpm, arg.ID)
	return err
}

const updateTrackNotes = `-- name: UpdateTrackNotes :one
UPDATE tracks
SET notes = ?,
    notes_author_name = ?,
    notes_updated_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, project_id, title, artist, album, active_version_id, created_at, updated_at, track_order, "key", bpm, public_id, notes, notes_author_name, notes_updated_at, visibility_status, allow_editing, allow_downloads, password_hash, origin_instance_url, shared_with_instance_users
`

type UpdateTrackNotesParams struct {
	Notes           sql.NullString `json:"notes"`
	NotesAuthorName sql.NullString `json:"notes_author_name"`
	ID              int64          `json:"id"`
	UserID          int64          `json:"user_id"`
}

func (q *Queries) UpdateTrackNotes(ctx context.Context, arg UpdateTrackNotesParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, updateTrackNotes,
		arg.Notes,
		arg.NotesAuthorName,
		arg.ID,
		arg.UserID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Artist,
		&i.Album,
		&i.ActiveVersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TrackOrder,
		&i.Key,
		&i.Bpm,
		&i.PublicID,
		&i.Notes,
		&i.NotesAuthorName,
		&i.NotesUpdatedAt,
		&i.VisibilityStatus,
		&i.AllowEditing,
		&i.AllowDownloads,
		&i.PasswordHash,
		&i.OriginInstanceUrl,
		&i.SharedWithInstanceUsers,
	)
	return i, err
}

const updateTrackOrder = `-- name: UpdateTrackOrder :exec
UPDATE tracks
SET track_order = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateTrackOrderParams struct {
	TrackOrder int64 `json:"track_order"`
	ID         int64 `json:"id"`
}

func (q *Queries) UpdateTrackOrder(ctx context.Context, arg UpdateTrackOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateTrackOrder, arg.TrackOrder, arg.ID)
	return err
}
